[entropy_control] ./tests/verify_v1.py:3:from core.crypto.entropy import verify_stealth
[entropy_control] ./tests/verify_final.py:3:from core.crypto.entropy import verify_indistinguishability
[entropy_control] ./aegis_grid.egg-info/SOURCES.txt:33:core/crypto/entropy.py
[entropy_control] ./generate_validation.py:6:from core.crypto.entropy import calculate_entropy
[entropy_control] ./generate_validation.py:20:    h_cipher = calculate_entropy(res['ciphertext'])
[entropy_control] ./generate_validation.py:21:    h_dummy = calculate_entropy(os.urandom(len(res['ciphertext'])))
[entropy_control] ./.novelty_state/baseline.txt:1:[entropy_control] ./tests/verify_v1.py:3:from core.crypto.entropy import verify_stealth
[entropy_control] ./.novelty_state/baseline.txt:2:[entropy_control] ./tests/verify_final.py:3:from core.crypto.entropy import verify_indistinguishability
[entropy_control] ./.novelty_state/baseline.txt:3:[entropy_control] ./aegis_grid.egg-info/SOURCES.txt:33:core/crypto/entropy.py
[entropy_control] ./.novelty_state/baseline.txt:4:[entropy_control] ./generate_validation.py:6:from core.crypto.entropy import calculate_entropy
[entropy_control] ./.novelty_state/baseline.txt:5:[entropy_control] ./generate_validation.py:20:    h_cipher = calculate_entropy(res['ciphertext'])
[entropy_control] ./.novelty_state/baseline.txt:6:[entropy_control] ./generate_validation.py:21:    h_dummy = calculate_entropy(os.urandom(len(res['ciphertext'])))
[entropy_control] ./.novelty_state/baseline.txt:7:[entropy_control] ./core/superposition.py:2:# Constant-entropy system parameters
[entropy_control] ./.novelty_state/baseline.txt:8:[entropy_control] ./core/crypto/entropy.py:4:def shannon_entropy(data: bytes) -> float:
[entropy_control] ./.novelty_state/baseline.txt:9:[entropy_control] ./core/crypto/entropy.py:7:    entropy = 0.0
[entropy_control] ./.novelty_state/baseline.txt:10:[entropy_control] ./core/crypto/entropy.py:10:        entropy -= p * math.log2(p)
[entropy_control] ./.novelty_state/baseline.txt:11:[entropy_control] ./core/crypto/entropy.py:11:    return entropy
[entropy_control] ./.novelty_state/baseline.txt:12:[entropy_control] ./core/crypto/entropy.py:18:    return abs(shannon_entropy(b1) - shannon_entropy(b2)) < delta
[entropy_control] ./.novelty_state/baseline.txt:13:[entropy_control] ./network/traffic_shaper.py:3:def constant_entropy_send(packets, window_ms=50):
[entropy_control] ./core/superposition.py:2:# Constant-entropy system parameters
[entropy_control] ./core/crypto/entropy.py:4:def shannon_entropy(data: bytes) -> float:
[entropy_control] ./core/crypto/entropy.py:7:    entropy = 0.0
[entropy_control] ./core/crypto/entropy.py:10:        entropy -= p * math.log2(p)
[entropy_control] ./core/crypto/entropy.py:11:    return entropy
[entropy_control] ./core/crypto/entropy.py:18:    return abs(shannon_entropy(b1) - shannon_entropy(b2)) < delta
[entropy_control] ./network/traffic_shaper.py:3:def constant_entropy_send(packets, window_ms=50):
[fail_secure] ./.novelty_state/baseline.txt:14:[fail_secure] ./core/time_lock.py:6:    Enforces irreversible message expiry.
[fail_secure] ./core/time_lock.py:6:    Enforces irreversible message expiry.
[attack_pressure] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[attack_pressure] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[attack_pressure] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[attack_pressure] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[attack_pressure] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[attack_pressure] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[attack_pressure] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[attack_pressure] ./.novelty_state/baseline.txt:15:[attack_pressure] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[attack_pressure] ./.novelty_state/baseline.txt:16:[attack_pressure] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[attack_pressure] ./.novelty_state/baseline.txt:17:[attack_pressure] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[attack_pressure] ./.novelty_state/baseline.txt:18:[attack_pressure] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[attack_pressure] ./.novelty_state/baseline.txt:19:[attack_pressure] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[attack_pressure] ./.novelty_state/baseline.txt:20:[attack_pressure] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[attack_pressure] ./.novelty_state/baseline.txt:21:[attack_pressure] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[attack_pressure] ./.novelty_state/baseline.txt:22:[attack_pressure] ./generate_plots.py:8:    pressure = np.cumsum([0.2, 0.5, 0.8, 1.5, 2.5])
[attack_pressure] ./.novelty_state/baseline.txt:23:[attack_pressure] ./generate_plots.py:24:    plt.step(range(len(pressure)), pressure, where='post', color='purple', label='CAP Score')
[attack_pressure] ./.novelty_state/baseline.txt:24:[attack_pressure] ./agents/secure_agent.py:9:        self.pressure = 0.0
[attack_pressure] ./.novelty_state/baseline.txt:25:[attack_pressure] ./agents/secure_agent.py:20:    def add_attack_pressure(self, amount):
[attack_pressure] ./.novelty_state/baseline.txt:26:[attack_pressure] ./agents/secure_agent.py:22:        self.pressure += amount
[attack_pressure] ./.novelty_state/baseline.txt:27:[attack_pressure] ./agents/secure_agent.py:23:        if self.pressure >= self.PRESSURE_LIMIT:
[attack_pressure] ./.novelty_state/baseline.txt:28:[attack_pressure] ./agents/secure_agent.py:25:            print(f"[V1-SECURITY] LOCKOUT TRIGGERED -> Pressure: {self.pressure:.2f}")
[attack_pressure] ./.novelty_state/baseline.txt:38:[agent_autonomy] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[attack_pressure] ./.novelty_state/baseline.txt:41:[agent_autonomy] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[attack_pressure] ./.novelty_state/baseline.txt:58:[agent_autonomy] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[attack_pressure] ./.novelty_state/baseline.txt:66:[agent_autonomy] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[attack_pressure] ./.novelty_state/baseline.txt:70:[agent_autonomy] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[attack_pressure] ./.novelty_state/baseline.txt:74:[agent_autonomy] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[attack_pressure] ./.novelty_state/baseline.txt:113:[agent_autonomy] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[attack_pressure] ./.novelty_state/baseline.txt:115:[agent_autonomy] ./.novelty_state/current.txt:15:[attack_pressure] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[attack_pressure] ./.novelty_state/baseline.txt:116:[agent_autonomy] ./.novelty_state/current.txt:16:[attack_pressure] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[attack_pressure] ./.novelty_state/baseline.txt:117:[agent_autonomy] ./.novelty_state/current.txt:17:[attack_pressure] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[attack_pressure] ./.novelty_state/baseline.txt:118:[agent_autonomy] ./.novelty_state/current.txt:18:[attack_pressure] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[attack_pressure] ./.novelty_state/baseline.txt:119:[agent_autonomy] ./.novelty_state/current.txt:19:[attack_pressure] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[attack_pressure] ./.novelty_state/baseline.txt:120:[agent_autonomy] ./.novelty_state/current.txt:20:[attack_pressure] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[attack_pressure] ./.novelty_state/baseline.txt:121:[agent_autonomy] ./.novelty_state/current.txt:21:[attack_pressure] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[attack_pressure] ./.novelty_state/baseline.txt:122:[agent_autonomy] ./.novelty_state/current.txt:24:[attack_pressure] ./agents/secure_agent.py:9:        self.pressure = 0.0
[attack_pressure] ./.novelty_state/baseline.txt:123:[agent_autonomy] ./.novelty_state/current.txt:25:[attack_pressure] ./agents/secure_agent.py:20:    def add_attack_pressure(self, amount):
[attack_pressure] ./.novelty_state/baseline.txt:124:[agent_autonomy] ./.novelty_state/current.txt:26:[attack_pressure] ./agents/secure_agent.py:22:        self.pressure += amount
[attack_pressure] ./.novelty_state/baseline.txt:125:[agent_autonomy] ./.novelty_state/current.txt:27:[attack_pressure] ./agents/secure_agent.py:23:        if self.pressure >= self.PRESSURE_LIMIT:
[attack_pressure] ./.novelty_state/baseline.txt:126:[agent_autonomy] ./.novelty_state/current.txt:28:[attack_pressure] ./agents/secure_agent.py:25:            print(f"[V1-SECURITY] LOCKOUT TRIGGERED -> Pressure: {self.pressure:.2f}")
[attack_pressure] ./.novelty_state/baseline.txt:135:[agent_autonomy] ./.novelty_state/current.txt:38:[agent_autonomy] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[attack_pressure] ./.novelty_state/baseline.txt:138:[agent_autonomy] ./.novelty_state/current.txt:41:[agent_autonomy] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[attack_pressure] ./.novelty_state/baseline.txt:155:[agent_autonomy] ./.novelty_state/current.txt:58:[agent_autonomy] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[attack_pressure] ./.novelty_state/baseline.txt:163:[agent_autonomy] ./.novelty_state/current.txt:66:[agent_autonomy] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[attack_pressure] ./.novelty_state/baseline.txt:167:[agent_autonomy] ./.novelty_state/current.txt:70:[agent_autonomy] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[attack_pressure] ./.novelty_state/baseline.txt:171:[agent_autonomy] ./.novelty_state/current.txt:74:[agent_autonomy] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[attack_pressure] ./.novelty_state/baseline.txt:219:[agent_autonomy] ./agents/secure_agent.py:9:        self.pressure = 0.0
[attack_pressure] ./.novelty_state/baseline.txt:227:[agent_autonomy] ./agents/secure_agent.py:20:    def add_attack_pressure(self, amount):
[attack_pressure] ./.novelty_state/baseline.txt:229:[agent_autonomy] ./agents/secure_agent.py:22:        self.pressure += amount
[attack_pressure] ./.novelty_state/baseline.txt:230:[agent_autonomy] ./agents/secure_agent.py:23:        if self.pressure >= self.PRESSURE_LIMIT:
[attack_pressure] ./.novelty_state/baseline.txt:232:[agent_autonomy] ./agents/secure_agent.py:25:            print(f"[V1-SECURITY] LOCKOUT TRIGGERED -> Pressure: {self.pressure:.2f}")
[attack_pressure] ./.novelty_state/current.txt:29:[attack_pressure] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[attack_pressure] ./.novelty_state/current.txt:30:[attack_pressure] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[attack_pressure] ./.novelty_state/current.txt:31:[attack_pressure] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[attack_pressure] ./.novelty_state/current.txt:32:[attack_pressure] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[attack_pressure] ./.novelty_state/current.txt:33:[attack_pressure] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[attack_pressure] ./.novelty_state/current.txt:34:[attack_pressure] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[attack_pressure] ./.novelty_state/current.txt:35:[attack_pressure] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[attack_pressure] ./.novelty_state/current.txt:36:[attack_pressure] ./.novelty_state/baseline.txt:15:[attack_pressure] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[attack_pressure] ./.novelty_state/current.txt:37:[attack_pressure] ./.novelty_state/baseline.txt:16:[attack_pressure] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[attack_pressure] ./.novelty_state/current.txt:38:[attack_pressure] ./.novelty_state/baseline.txt:17:[attack_pressure] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[attack_pressure] ./.novelty_state/current.txt:39:[attack_pressure] ./.novelty_state/baseline.txt:18:[attack_pressure] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[attack_pressure] ./.novelty_state/current.txt:40:[attack_pressure] ./.novelty_state/baseline.txt:19:[attack_pressure] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[attack_pressure] ./.novelty_state/current.txt:41:[attack_pressure] ./.novelty_state/baseline.txt:20:[attack_pressure] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[attack_pressure] ./.novelty_state/current.txt:42:[attack_pressure] ./.novelty_state/baseline.txt:21:[attack_pressure] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[attack_pressure] ./.novelty_state/current.txt:43:[attack_pressure] ./.novelty_state/baseline.txt:22:[attack_pressure] ./generate_plots.py:8:    pressure = np.cumsum([0.2, 0.5, 0.8, 1.5, 2.5])
[attack_pressure] ./.novelty_state/current.txt:44:[attack_pressure] ./.novelty_state/baseline.txt:23:[attack_pressure] ./generate_plots.py:24:    plt.step(range(len(pressure)), pressure, where='post', color='purple', label='CAP Score')
[attack_pressure] ./.novelty_state/current.txt:45:[attack_pressure] ./.novelty_state/baseline.txt:24:[attack_pressure] ./agents/secure_agent.py:9:        self.pressure = 0.0
[attack_pressure] ./.novelty_state/current.txt:46:[attack_pressure] ./.novelty_state/baseline.txt:25:[attack_pressure] ./agents/secure_agent.py:20:    def add_attack_pressure(self, amount):
[attack_pressure] ./.novelty_state/current.txt:47:[attack_pressure] ./.novelty_state/baseline.txt:26:[attack_pressure] ./agents/secure_agent.py:22:        self.pressure += amount
[attack_pressure] ./.novelty_state/current.txt:48:[attack_pressure] ./.novelty_state/baseline.txt:27:[attack_pressure] ./agents/secure_agent.py:23:        if self.pressure >= self.PRESSURE_LIMIT:
[attack_pressure] ./.novelty_state/current.txt:49:[attack_pressure] ./.novelty_state/baseline.txt:28:[attack_pressure] ./agents/secure_agent.py:25:            print(f"[V1-SECURITY] LOCKOUT TRIGGERED -> Pressure: {self.pressure:.2f}")
[attack_pressure] ./.novelty_state/current.txt:50:[attack_pressure] ./.novelty_state/baseline.txt:38:[agent_autonomy] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[attack_pressure] ./.novelty_state/current.txt:51:[attack_pressure] ./.novelty_state/baseline.txt:41:[agent_autonomy] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[attack_pressure] ./.novelty_state/current.txt:52:[attack_pressure] ./.novelty_state/baseline.txt:58:[agent_autonomy] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[attack_pressure] ./.novelty_state/current.txt:53:[attack_pressure] ./.novelty_state/baseline.txt:66:[agent_autonomy] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[attack_pressure] ./.novelty_state/current.txt:54:[attack_pressure] ./.novelty_state/baseline.txt:70:[agent_autonomy] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[attack_pressure] ./.novelty_state/current.txt:55:[attack_pressure] ./.novelty_state/baseline.txt:74:[agent_autonomy] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[attack_pressure] ./.novelty_state/current.txt:56:[attack_pressure] ./.novelty_state/baseline.txt:113:[agent_autonomy] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[attack_pressure] ./.novelty_state/current.txt:57:[attack_pressure] ./.novelty_state/baseline.txt:115:[agent_autonomy] ./.novelty_state/current.txt:15:[attack_pressure] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[attack_pressure] ./.novelty_state/current.txt:58:[attack_pressure] ./.novelty_state/baseline.txt:116:[agent_autonomy] ./.novelty_state/current.txt:16:[attack_pressure] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[attack_pressure] ./.novelty_state/current.txt:59:[attack_pressure] ./.novelty_state/baseline.txt:117:[agent_autonomy] ./.novelty_state/current.txt:17:[attack_pressure] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[attack_pressure] ./.novelty_state/current.txt:60:[attack_pressure] ./.novelty_state/baseline.txt:118:[agent_autonomy] ./.novelty_state/current.txt:18:[attack_pressure] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[attack_pressure] ./.novelty_state/current.txt:61:[attack_pressure] ./.novelty_state/baseline.txt:119:[agent_autonomy] ./.novelty_state/current.txt:19:[attack_pressure] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[attack_pressure] ./.novelty_state/current.txt:62:[attack_pressure] ./.novelty_state/baseline.txt:120:[agent_autonomy] ./.novelty_state/current.txt:20:[attack_pressure] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[attack_pressure] ./.novelty_state/current.txt:63:[attack_pressure] ./.novelty_state/baseline.txt:121:[agent_autonomy] ./.novelty_state/current.txt:21:[attack_pressure] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[attack_pressure] ./.novelty_state/current.txt:64:[attack_pressure] ./.novelty_state/baseline.txt:122:[agent_autonomy] ./.novelty_state/current.txt:24:[attack_pressure] ./agents/secure_agent.py:9:        self.pressure = 0.0
[attack_pressure] ./.novelty_state/current.txt:65:[attack_pressure] ./.novelty_state/baseline.txt:123:[agent_autonomy] ./.novelty_state/current.txt:25:[attack_pressure] ./agents/secure_agent.py:20:    def add_attack_pressure(self, amount):
[attack_pressure] ./.novelty_state/current.txt:66:[attack_pressure] ./.novelty_state/baseline.txt:124:[agent_autonomy] ./.novelty_state/current.txt:26:[attack_pressure] ./agents/secure_agent.py:22:        self.pressure += amount
[attack_pressure] ./.novelty_state/current.txt:67:[attack_pressure] ./.novelty_state/baseline.txt:125:[agent_autonomy] ./.novelty_state/current.txt:27:[attack_pressure] ./agents/secure_agent.py:23:        if self.pressure >= self.PRESSURE_LIMIT:
[attack_pressure] ./.novelty_state/current.txt:68:[attack_pressure] ./.novelty_state/baseline.txt:126:[agent_autonomy] ./.novelty_state/current.txt:28:[attack_pressure] ./agents/secure_agent.py:25:            print(f"[V1-SECURITY] LOCKOUT TRIGGERED -> Pressure: {self.pressure:.2f}")
[attack_pressure] ./.novelty_state/current.txt:69:[attack_pressure] ./.novelty_state/baseline.txt:135:[agent_autonomy] ./.novelty_state/current.txt:38:[agent_autonomy] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[attack_pressure] ./.novelty_state/current.txt:70:[attack_pressure] ./.novelty_state/baseline.txt:138:[agent_autonomy] ./.novelty_state/current.txt:41:[agent_autonomy] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[attack_pressure] ./.novelty_state/current.txt:71:[attack_pressure] ./.novelty_state/baseline.txt:155:[agent_autonomy] ./.novelty_state/current.txt:58:[agent_autonomy] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[attack_pressure] ./.novelty_state/current.txt:72:[attack_pressure] ./.novelty_state/baseline.txt:163:[agent_autonomy] ./.novelty_state/current.txt:66:[agent_autonomy] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[attack_pressure] ./.novelty_state/current.txt:73:[attack_pressure] ./.novelty_state/baseline.txt:167:[agent_autonomy] ./.novelty_state/current.txt:70:[agent_autonomy] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[attack_pressure] ./.novelty_state/current.txt:74:[attack_pressure] ./.novelty_state/baseline.txt:171:[agent_autonomy] ./.novelty_state/current.txt:74:[agent_autonomy] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[attack_pressure] ./.novelty_state/current.txt:75:[attack_pressure] ./.novelty_state/baseline.txt:219:[agent_autonomy] ./agents/secure_agent.py:9:        self.pressure = 0.0
[attack_pressure] ./.novelty_state/current.txt:76:[attack_pressure] ./.novelty_state/baseline.txt:227:[agent_autonomy] ./agents/secure_agent.py:20:    def add_attack_pressure(self, amount):
[attack_pressure] ./.novelty_state/current.txt:77:[attack_pressure] ./.novelty_state/baseline.txt:229:[agent_autonomy] ./agents/secure_agent.py:22:        self.pressure += amount
[attack_pressure] ./.novelty_state/current.txt:78:[attack_pressure] ./.novelty_state/baseline.txt:230:[agent_autonomy] ./agents/secure_agent.py:23:        if self.pressure >= self.PRESSURE_LIMIT:
[attack_pressure] ./.novelty_state/current.txt:79:[attack_pressure] ./.novelty_state/baseline.txt:232:[agent_autonomy] ./agents/secure_agent.py:25:            print(f"[V1-SECURITY] LOCKOUT TRIGGERED -> Pressure: {self.pressure:.2f}")
[attack_pressure] ./.novelty_state/current.txt:80:[attack_pressure] ./.novelty_state/current.txt:29:[attack_pressure] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[attack_pressure] ./.novelty_state/current.txt:81:[attack_pressure] ./.novelty_state/current.txt:30:[attack_pressure] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[attack_pressure] ./.novelty_state/current.txt:82:[attack_pressure] ./.novelty_state/current.txt:31:[attack_pressure] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[attack_pressure] ./.novelty_state/current.txt:83:[attack_pressure] ./.novelty_state/current.txt:32:[attack_pressure] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10
[attack_pressure] ./generate_plots.py:8:    pressure = np.cumsum([0.2, 0.5, 0.8, 1.5, 2.5])
[attack_pressure] ./generate_plots.py:24:    plt.step(range(len(pressure)), pressure, where='post', color='purple', label='CAP Score')
[attack_pressure] ./agents/secure_agent.py:9:        self.pressure = 0.0
[attack_pressure] ./agents/secure_agent.py:20:    def add_attack_pressure(self, amount):
[attack_pressure] ./agents/secure_agent.py:22:        self.pressure += amount
[attack_pressure] ./agents/secure_agent.py:23:        if self.pressure >= self.PRESSURE_LIMIT:
[attack_pressure] ./agents/secure_agent.py:25:            print(f"[V1-SECURITY] LOCKOUT TRIGGERED -> Pressure: {self.pressure:.2f}")
[adaptive_threshold] ./protocol/receiver.py:7:    if len(packets) < agent.threshold:
[adaptive_threshold] ./protocol/receiver.py:25:    return len(seen) >= agent.threshold
[adaptive_threshold] ./Aegis_Grid_V2_Technical_Summary.txt:11:- Autonomous (n, k) threshold adaptation based on real-time stochastic loss.
[adaptive_threshold] ./.novelty_state/baseline.txt:29:[adaptive_threshold] ./protocol/receiver.py:7:    if len(packets) < agent.threshold:
[adaptive_threshold] ./.novelty_state/baseline.txt:30:[adaptive_threshold] ./protocol/receiver.py:25:    return len(seen) >= agent.threshold
[adaptive_threshold] ./.novelty_state/baseline.txt:31:[adaptive_threshold] ./Aegis_Grid_V2_Technical_Summary.txt:11:- Autonomous (n, k) threshold adaptation based on real-time stochastic loss.
[adaptive_threshold] ./.novelty_state/baseline.txt:32:[adaptive_threshold] ./agents/secure_agent.py:11:        self.threshold = 12
[adaptive_threshold] ./.novelty_state/baseline.txt:33:[adaptive_threshold] ./agents/secure_agent.py:18:        self.threshold = max(4, int(self.fragment_count * (1.0 - loss)))
[adaptive_threshold] ./.novelty_state/baseline.txt:34:[adaptive_threshold] ./agents/learning_agent.py:3:    Online adaptive security agent.
[adaptive_threshold] ./.novelty_state/baseline.txt:37:[agent_autonomy] ./protocol/receiver.py:7:    if len(packets) < agent.threshold:
[adaptive_threshold] ./.novelty_state/baseline.txt:43:[agent_autonomy] ./protocol/receiver.py:25:    return len(seen) >= agent.threshold
[adaptive_threshold] ./.novelty_state/baseline.txt:127:[agent_autonomy] ./.novelty_state/current.txt:29:[adaptive_threshold] ./protocol/receiver.py:7:    if len(packets) < agent.threshold:
[adaptive_threshold] ./.novelty_state/baseline.txt:128:[agent_autonomy] ./.novelty_state/current.txt:30:[adaptive_threshold] ./protocol/receiver.py:25:    return len(seen) >= agent.threshold
[adaptive_threshold] ./.novelty_state/baseline.txt:129:[agent_autonomy] ./.novelty_state/current.txt:32:[adaptive_threshold] ./agents/secure_agent.py:11:        self.threshold = 12
[adaptive_threshold] ./.novelty_state/baseline.txt:130:[agent_autonomy] ./.novelty_state/current.txt:33:[adaptive_threshold] ./agents/secure_agent.py:18:        self.threshold = max(4, int(self.fragment_count * (1.0 - loss)))
[adaptive_threshold] ./.novelty_state/baseline.txt:131:[agent_autonomy] ./.novelty_state/current.txt:34:[adaptive_threshold] ./agents/learning_agent.py:3:    Online adaptive security agent.
[adaptive_threshold] ./.novelty_state/baseline.txt:134:[agent_autonomy] ./.novelty_state/current.txt:37:[agent_autonomy] ./protocol/receiver.py:7:    if len(packets) < agent.threshold:
[adaptive_threshold] ./.novelty_state/baseline.txt:140:[agent_autonomy] ./.novelty_state/current.txt:43:[agent_autonomy] ./protocol/receiver.py:25:    return len(seen) >= agent.threshold
[adaptive_threshold] ./.novelty_state/baseline.txt:221:[agent_autonomy] ./agents/secure_agent.py:11:        self.threshold = 12
[adaptive_threshold] ./.novelty_state/baseline.txt:226:[agent_autonomy] ./agents/secure_agent.py:18:        self.threshold = max(4, int(self.fragment_count * (1.0 - loss)))
[adaptive_threshold] ./.novelty_state/baseline.txt:237:[agent_autonomy] ./agents/learning_agent.py:3:    Online adaptive security agent.
[adaptive_threshold] ./agents/secure_agent.py:11:        self.threshold = 12
[adaptive_threshold] ./agents/secure_agent.py:18:        self.threshold = max(4, int(self.fragment_count * (1.0 - loss)))
[adaptive_threshold] ./agents/learning_agent.py:3:    Online adaptive security agent.
[agent_autonomy] ./protocol/receiver.py:3:def receive_and_reconstruct(packets, agent):
[agent_autonomy] ./protocol/receiver.py:4:    if agent.is_locked() or not packets:
[agent_autonomy] ./protocol/receiver.py:7:    if len(packets) < agent.threshold:
[agent_autonomy] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[agent_autonomy] ./protocol/receiver.py:9:        if agent.is_locked():
[agent_autonomy] ./protocol/receiver.py:17:        key = agent.get_layer_key(p.frag_id)
[agent_autonomy] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[agent_autonomy] ./protocol/receiver.py:22:        if agent.is_locked():
[agent_autonomy] ./protocol/receiver.py:25:    return len(seen) >= agent.threshold
[agent_autonomy] ./protocol/packet.py:4:    def __init__(self, ciphertext, nonce, tag, cert, timestamp):
[agent_autonomy] ./protocol/packet.py:5:        self.ciphertext = ciphertext
[agent_autonomy] ./protocol/packet.py:6:        self.nonce = nonce
[agent_autonomy] ./protocol/packet.py:7:        self.tag = tag
[agent_autonomy] ./protocol/packet.py:8:        self.cert = cert
[agent_autonomy] ./protocol/packet.py:9:        self.timestamp = timestamp
[agent_autonomy] ./protocol/sender.py:6:def generate_traffic(agent, data, dummy_ratio):
[agent_autonomy] ./protocol/sender.py:7:    assert hasattr(agent, "fragment_count"), "Agent contract violated"
[agent_autonomy] ./protocol/sender.py:14:        layer_key = agent.get_layer_key(i)
[agent_autonomy] ./protocol/sender.py:19:            total_frags=agent.fragment_count,
[agent_autonomy] ./protocol/sender.py:30:        pkt = Packet(msg_id, i, agent.fragment_count, os.urandom(1))
[agent_autonomy] ./protocol/sender.py:31:        pkt.signature = signer.sign(pkt.signable(), agent.get_layer_key(i))
[agent_autonomy] ./simulation/run_experiments.py:4:def run_all(agent, traffic_fn, receiver_fn):
[agent_autonomy] ./simulation/run_experiments.py:13:            agent.locked = False
[agent_autonomy] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[agent_autonomy] ./simulation/run_experiments.py:15:            agent._lock_announced = False
[agent_autonomy] ./simulation/run_experiments.py:18:            agent.observe(loss)
[agent_autonomy] ./simulation/run_experiments.py:21:            packets = traffic_fn(agent, b"POWER_GRID_CMD", 0.2)
[agent_autonomy] ./simulation/run_experiments.py:25:            if agent.is_locked():
[agent_autonomy] ./simulation/run_experiments.py:27:            elif receiver_fn(packets, agent):
[agent_autonomy] ./tests/verify_v1.py:4:from agents.secure_agent import SecureAgent
[agent_autonomy] ./tests/verify_v1.py:19:    agent = SecureAgent(os.urandom(32))
[agent_autonomy] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[agent_autonomy] ./tests/verify_v1.py:21:    print(f"Layer 7 (Safety):   {'✅ LOCKED' if agent.is_locked() else '❌ FAIL'}")
[agent_autonomy] ./tests/verify_final.py:4:from agents.secure_agent import SecureAgent
[agent_autonomy] ./tests/verify_final.py:24:    agent = SecureAgent(os.urandom(32))
[agent_autonomy] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[agent_autonomy] ./tests/verify_v2.py:4:from agents.secure_agent import SecureAgentV2
[agent_autonomy] ./tests/verify_v2.py:14:    agent = SecureAgentV2(os.urandom(32))
[agent_autonomy] ./tests/verify_v2.py:16:    print(f"Layer 7 (Time-Freshness):  {'✅ VALID' if agent.is_time_valid(valid_ts) else '❌ FAIL'}")
[agent_autonomy] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[agent_autonomy] ./tests/verify_v2.py:19:    print(f"Layer 7 (Safety Sink):     {'✅ LOCKED' if agent.is_locked() else '❌ FAIL'}")
[agent_autonomy] ./receiver.py:4:    def __init__(self, agent):
[agent_autonomy] ./receiver.py:5:        self.agent = agent
[agent_autonomy] ./receiver.py:7:        self.epoch_size = 10
[agent_autonomy] ./receiver.py:8:        self.epoch_invalid = 0
[agent_autonomy] ./receiver.py:9:        self.epoch_total = 0
[agent_autonomy] ./receiver.py:11:        self.bad_epochs = deque(maxlen=3)
[agent_autonomy] ./receiver.py:13:    def receive(self, fragments, forged=False, replay=False):
[agent_autonomy] ./receiver.py:14:        if self.agent.locked:
[agent_autonomy] ./receiver.py:17:        self.epoch_total += len(fragments)
[agent_autonomy] ./receiver.py:20:            self.epoch_invalid += len(fragments)
[agent_autonomy] ./receiver.py:22:        if self.epoch_total >= self.epoch_size:
[agent_autonomy] ./receiver.py:23:            ratio = self.epoch_invalid / self.epoch_total
[agent_autonomy] ./receiver.py:24:            if ratio > self.agent.max_invalid_ratio:
[agent_autonomy] ./receiver.py:25:                print(f"[SECURITY] FORGERY sustained {self.epoch_invalid}/{self.epoch_total} → NODE LOCKED")
[agent_autonomy] ./receiver.py:26:                self.agent.locked = True
[agent_autonomy] ./receiver.py:28:            self.epoch_invalid = 0
[agent_autonomy] ./receiver.py:29:            self.epoch_total = 0
[agent_autonomy] ./error_log.txt:2:  File "/workspaces/agentic-secure-grid-communication/main.py", line 3, in <module>
[agent_autonomy] ./error_log.txt:4:  File "/workspaces/agentic-secure-grid-communication/protocol/sender.py", line 3, in <module>
[agent_autonomy] ./error_log.txt:6:  File "/workspaces/agentic-secure-grid-communication/core/crypto.py", line 13
[agent_autonomy] ./error_log.txt:7:    return data        cd /workspaces/agentic-secure-grid-communication && python main.py 2>&1 | tee error_log.txt
[agent_autonomy] ./main.py:2:from agents.secure_agent import SecureAgent
[agent_autonomy] ./main.py:20:        agent = SecureAgent(master_key)
[agent_autonomy] ./main.py:21:        run_all(agent, generate_traffic, receive_and_reconstruct)
[agent_autonomy] ./aegis_grid.egg-info/SOURCES.txt:10:aegis_grid/agents/__init__.py
[agent_autonomy] ./aegis_grid.egg-info/SOURCES.txt:14:agents/__init__.py
[agent_autonomy] ./aegis_grid.egg-info/SOURCES.txt:15:agents/learning_agent.py
[agent_autonomy] ./aegis_grid.egg-info/SOURCES.txt:16:agents/network_agent.py
[agent_autonomy] ./aegis_grid.egg-info/SOURCES.txt:17:agents/receiver_agent.py
[agent_autonomy] ./aegis_grid.egg-info/SOURCES.txt:18:agents/secure_agent.py
[agent_autonomy] ./aegis_grid.egg-info/SOURCES.txt:19:agents/sender_agent.py
[agent_autonomy] ./aegis_grid.egg-info/top_level.txt:2:agents
[agent_autonomy] ./verify_model.py:2:from agents.secure_agent import SecureAgent
[agent_autonomy] ./verify_model.py:9:        "Agentic CAP Logic": "agents/secure_agent.py",
[agent_autonomy] ./.vault/logic_blueprints/audit_v2.py:9:from v2_model.agents.secure_agent_v2 import AgentV2
[agent_autonomy] ./.vault/logic_blueprints/audit_v2.py:20:    agent = AgentV2(os.urandom(32))
[agent_autonomy] ./.vault/logic_blueprints/audit_v2.py:21:    print(f"Time-Bounded Policy:     {'✅ ACTIVE' if agent.is_fresh(time.time() - 0.5) else '❌ FAIL'}")
[agent_autonomy] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[agent_autonomy] ./.vault/logic_blueprints/audit_v2.py:25:    print(f"V2 Safety Sink:          {'✅ LOCKED' if agent.locked else '❌ FAIL'}")
[agent_autonomy] ./.novelty_state/baseline.txt:15:[attack_pressure] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[agent_autonomy] ./.novelty_state/baseline.txt:16:[attack_pressure] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[agent_autonomy] ./.novelty_state/baseline.txt:17:[attack_pressure] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[agent_autonomy] ./.novelty_state/baseline.txt:18:[attack_pressure] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[agent_autonomy] ./.novelty_state/baseline.txt:19:[attack_pressure] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[agent_autonomy] ./.novelty_state/baseline.txt:20:[attack_pressure] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[agent_autonomy] ./.novelty_state/baseline.txt:21:[attack_pressure] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[agent_autonomy] ./.novelty_state/baseline.txt:24:[attack_pressure] ./agents/secure_agent.py:9:        self.pressure = 0.0
[agent_autonomy] ./.novelty_state/baseline.txt:25:[attack_pressure] ./agents/secure_agent.py:20:    def add_attack_pressure(self, amount):
[agent_autonomy] ./.novelty_state/baseline.txt:26:[attack_pressure] ./agents/secure_agent.py:22:        self.pressure += amount
[agent_autonomy] ./.novelty_state/baseline.txt:27:[attack_pressure] ./agents/secure_agent.py:23:        if self.pressure >= self.PRESSURE_LIMIT:
[agent_autonomy] ./.novelty_state/baseline.txt:28:[attack_pressure] ./agents/secure_agent.py:25:            print(f"[V1-SECURITY] LOCKOUT TRIGGERED -> Pressure: {self.pressure:.2f}")
[agent_autonomy] ./.novelty_state/baseline.txt:29:[adaptive_threshold] ./protocol/receiver.py:7:    if len(packets) < agent.threshold:
[agent_autonomy] ./.novelty_state/baseline.txt:30:[adaptive_threshold] ./protocol/receiver.py:25:    return len(seen) >= agent.threshold
[agent_autonomy] ./.novelty_state/baseline.txt:32:[adaptive_threshold] ./agents/secure_agent.py:11:        self.threshold = 12
[agent_autonomy] ./.novelty_state/baseline.txt:33:[adaptive_threshold] ./agents/secure_agent.py:18:        self.threshold = max(4, int(self.fragment_count * (1.0 - loss)))
[agent_autonomy] ./.novelty_state/baseline.txt:34:[adaptive_threshold] ./agents/learning_agent.py:3:    Online adaptive security agent.
[agent_autonomy] ./.novelty_state/baseline.txt:35:[agent_autonomy] ./protocol/receiver.py:3:def receive_and_reconstruct(packets, agent):
[agent_autonomy] ./.novelty_state/baseline.txt:36:[agent_autonomy] ./protocol/receiver.py:4:    if agent.is_locked() or not packets:
[agent_autonomy] ./.novelty_state/baseline.txt:37:[agent_autonomy] ./protocol/receiver.py:7:    if len(packets) < agent.threshold:
[agent_autonomy] ./.novelty_state/baseline.txt:38:[agent_autonomy] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[agent_autonomy] ./.novelty_state/baseline.txt:39:[agent_autonomy] ./protocol/receiver.py:9:        if agent.is_locked():
[agent_autonomy] ./.novelty_state/baseline.txt:40:[agent_autonomy] ./protocol/receiver.py:17:        key = agent.get_layer_key(p.frag_id)
[agent_autonomy] ./.novelty_state/baseline.txt:41:[agent_autonomy] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[agent_autonomy] ./.novelty_state/baseline.txt:42:[agent_autonomy] ./protocol/receiver.py:22:        if agent.is_locked():
[agent_autonomy] ./.novelty_state/baseline.txt:43:[agent_autonomy] ./protocol/receiver.py:25:    return len(seen) >= agent.threshold
[agent_autonomy] ./.novelty_state/baseline.txt:44:[agent_autonomy] ./protocol/packet.py:4:    def __init__(self, ciphertext, nonce, tag, cert, timestamp):
[agent_autonomy] ./.novelty_state/baseline.txt:45:[agent_autonomy] ./protocol/packet.py:5:        self.ciphertext = ciphertext
[agent_autonomy] ./.novelty_state/baseline.txt:46:[agent_autonomy] ./protocol/packet.py:6:        self.nonce = nonce
[agent_autonomy] ./.novelty_state/baseline.txt:47:[agent_autonomy] ./protocol/packet.py:7:        self.tag = tag
[agent_autonomy] ./.novelty_state/baseline.txt:48:[agent_autonomy] ./protocol/packet.py:8:        self.cert = cert
[agent_autonomy] ./.novelty_state/baseline.txt:49:[agent_autonomy] ./protocol/packet.py:9:        self.timestamp = timestamp
[agent_autonomy] ./.novelty_state/baseline.txt:50:[agent_autonomy] ./protocol/sender.py:6:def generate_traffic(agent, data, dummy_ratio):
[agent_autonomy] ./.novelty_state/baseline.txt:51:[agent_autonomy] ./protocol/sender.py:7:    assert hasattr(agent, "fragment_count"), "Agent contract violated"
[agent_autonomy] ./.novelty_state/baseline.txt:52:[agent_autonomy] ./protocol/sender.py:14:        layer_key = agent.get_layer_key(i)
[agent_autonomy] ./.novelty_state/baseline.txt:53:[agent_autonomy] ./protocol/sender.py:19:            total_frags=agent.fragment_count,
[agent_autonomy] ./.novelty_state/baseline.txt:54:[agent_autonomy] ./protocol/sender.py:30:        pkt = Packet(msg_id, i, agent.fragment_count, os.urandom(1))
[agent_autonomy] ./.novelty_state/baseline.txt:55:[agent_autonomy] ./protocol/sender.py:31:        pkt.signature = signer.sign(pkt.signable(), agent.get_layer_key(i))
[agent_autonomy] ./.novelty_state/baseline.txt:56:[agent_autonomy] ./simulation/run_experiments.py:4:def run_all(agent, traffic_fn, receiver_fn):
[agent_autonomy] ./.novelty_state/baseline.txt:57:[agent_autonomy] ./simulation/run_experiments.py:13:            agent.locked = False
[agent_autonomy] ./.novelty_state/baseline.txt:58:[agent_autonomy] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[agent_autonomy] ./.novelty_state/baseline.txt:59:[agent_autonomy] ./simulation/run_experiments.py:15:            agent._lock_announced = False
[agent_autonomy] ./.novelty_state/baseline.txt:60:[agent_autonomy] ./simulation/run_experiments.py:18:            agent.observe(loss)
[agent_autonomy] ./.novelty_state/baseline.txt:61:[agent_autonomy] ./simulation/run_experiments.py:21:            packets = traffic_fn(agent, b"POWER_GRID_CMD", 0.2)
[agent_autonomy] ./.novelty_state/baseline.txt:62:[agent_autonomy] ./simulation/run_experiments.py:25:            if agent.is_locked():
[agent_autonomy] ./.novelty_state/baseline.txt:63:[agent_autonomy] ./simulation/run_experiments.py:27:            elif receiver_fn(packets, agent):
[agent_autonomy] ./.novelty_state/baseline.txt:64:[agent_autonomy] ./tests/verify_v1.py:4:from agents.secure_agent import SecureAgent
[agent_autonomy] ./.novelty_state/baseline.txt:65:[agent_autonomy] ./tests/verify_v1.py:19:    agent = SecureAgent(os.urandom(32))
[agent_autonomy] ./.novelty_state/baseline.txt:66:[agent_autonomy] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[agent_autonomy] ./.novelty_state/baseline.txt:67:[agent_autonomy] ./tests/verify_v1.py:21:    print(f"Layer 7 (Safety):   {'✅ LOCKED' if agent.is_locked() else '❌ FAIL'}")
[agent_autonomy] ./.novelty_state/baseline.txt:68:[agent_autonomy] ./tests/verify_final.py:4:from agents.secure_agent import SecureAgent
[agent_autonomy] ./.novelty_state/baseline.txt:69:[agent_autonomy] ./tests/verify_final.py:24:    agent = SecureAgent(os.urandom(32))
[agent_autonomy] ./.novelty_state/baseline.txt:70:[agent_autonomy] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[agent_autonomy] ./.novelty_state/baseline.txt:71:[agent_autonomy] ./tests/verify_v2.py:4:from agents.secure_agent import SecureAgentV2
[agent_autonomy] ./.novelty_state/baseline.txt:72:[agent_autonomy] ./tests/verify_v2.py:14:    agent = SecureAgentV2(os.urandom(32))
[agent_autonomy] ./.novelty_state/baseline.txt:73:[agent_autonomy] ./tests/verify_v2.py:16:    print(f"Layer 7 (Time-Freshness):  {'✅ VALID' if agent.is_time_valid(valid_ts) else '❌ FAIL'}")
[agent_autonomy] ./.novelty_state/baseline.txt:74:[agent_autonomy] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[agent_autonomy] ./.novelty_state/baseline.txt:75:[agent_autonomy] ./tests/verify_v2.py:19:    print(f"Layer 7 (Safety Sink):     {'✅ LOCKED' if agent.is_locked() else '❌ FAIL'}")
[agent_autonomy] ./.novelty_state/baseline.txt:76:[agent_autonomy] ./receiver.py:4:    def __init__(self, agent):
[agent_autonomy] ./.novelty_state/baseline.txt:77:[agent_autonomy] ./receiver.py:5:        self.agent = agent
[agent_autonomy] ./.novelty_state/baseline.txt:78:[agent_autonomy] ./receiver.py:7:        self.epoch_size = 10
[agent_autonomy] ./.novelty_state/baseline.txt:79:[agent_autonomy] ./receiver.py:8:        self.epoch_invalid = 0
[agent_autonomy] ./.novelty_state/baseline.txt:80:[agent_autonomy] ./receiver.py:9:        self.epoch_total = 0
[agent_autonomy] ./.novelty_state/baseline.txt:81:[agent_autonomy] ./receiver.py:11:        self.bad_epochs = deque(maxlen=3)
[agent_autonomy] ./.novelty_state/baseline.txt:82:[agent_autonomy] ./receiver.py:13:    def receive(self, fragments, forged=False, replay=False):
[agent_autonomy] ./.novelty_state/baseline.txt:83:[agent_autonomy] ./receiver.py:14:        if self.agent.locked:
[agent_autonomy] ./.novelty_state/baseline.txt:84:[agent_autonomy] ./receiver.py:17:        self.epoch_total += len(fragments)
[agent_autonomy] ./.novelty_state/baseline.txt:85:[agent_autonomy] ./receiver.py:20:            self.epoch_invalid += len(fragments)
[agent_autonomy] ./.novelty_state/baseline.txt:86:[agent_autonomy] ./receiver.py:22:        if self.epoch_total >= self.epoch_size:
[agent_autonomy] ./.novelty_state/baseline.txt:87:[agent_autonomy] ./receiver.py:23:            ratio = self.epoch_invalid / self.epoch_total
[agent_autonomy] ./.novelty_state/baseline.txt:88:[agent_autonomy] ./receiver.py:24:            if ratio > self.agent.max_invalid_ratio:
[agent_autonomy] ./.novelty_state/baseline.txt:89:[agent_autonomy] ./receiver.py:25:                print(f"[SECURITY] FORGERY sustained {self.epoch_invalid}/{self.epoch_total} → NODE LOCKED")
[agent_autonomy] ./.novelty_state/baseline.txt:90:[agent_autonomy] ./receiver.py:26:                self.agent.locked = True
[agent_autonomy] ./.novelty_state/baseline.txt:91:[agent_autonomy] ./receiver.py:28:            self.epoch_invalid = 0
[agent_autonomy] ./.novelty_state/baseline.txt:92:[agent_autonomy] ./receiver.py:29:            self.epoch_total = 0
[agent_autonomy] ./.novelty_state/baseline.txt:93:[agent_autonomy] ./error_log.txt:2:  File "/workspaces/agentic-secure-grid-communication/main.py", line 3, in <module>
[agent_autonomy] ./.novelty_state/baseline.txt:94:[agent_autonomy] ./error_log.txt:4:  File "/workspaces/agentic-secure-grid-communication/protocol/sender.py", line 3, in <module>
[agent_autonomy] ./.novelty_state/baseline.txt:95:[agent_autonomy] ./error_log.txt:6:  File "/workspaces/agentic-secure-grid-communication/core/crypto.py", line 13
[agent_autonomy] ./.novelty_state/baseline.txt:96:[agent_autonomy] ./error_log.txt:7:    return data        cd /workspaces/agentic-secure-grid-communication && python main.py 2>&1 | tee error_log.txt
[agent_autonomy] ./.novelty_state/baseline.txt:97:[agent_autonomy] ./main.py:2:from agents.secure_agent import SecureAgent
[agent_autonomy] ./.novelty_state/baseline.txt:98:[agent_autonomy] ./main.py:20:        agent = SecureAgent(master_key)
[agent_autonomy] ./.novelty_state/baseline.txt:99:[agent_autonomy] ./main.py:21:        run_all(agent, generate_traffic, receive_and_reconstruct)
[agent_autonomy] ./.novelty_state/baseline.txt:100:[agent_autonomy] ./aegis_grid.egg-info/SOURCES.txt:10:aegis_grid/agents/__init__.py
[agent_autonomy] ./.novelty_state/baseline.txt:101:[agent_autonomy] ./aegis_grid.egg-info/SOURCES.txt:14:agents/__init__.py
[agent_autonomy] ./.novelty_state/baseline.txt:102:[agent_autonomy] ./aegis_grid.egg-info/SOURCES.txt:15:agents/learning_agent.py
[agent_autonomy] ./.novelty_state/baseline.txt:103:[agent_autonomy] ./aegis_grid.egg-info/SOURCES.txt:16:agents/network_agent.py
[agent_autonomy] ./.novelty_state/baseline.txt:104:[agent_autonomy] ./aegis_grid.egg-info/SOURCES.txt:17:agents/receiver_agent.py
[agent_autonomy] ./.novelty_state/baseline.txt:105:[agent_autonomy] ./aegis_grid.egg-info/SOURCES.txt:18:agents/secure_agent.py
[agent_autonomy] ./.novelty_state/baseline.txt:106:[agent_autonomy] ./aegis_grid.egg-info/SOURCES.txt:19:agents/sender_agent.py
[agent_autonomy] ./.novelty_state/baseline.txt:107:[agent_autonomy] ./aegis_grid.egg-info/top_level.txt:2:agents
[agent_autonomy] ./.novelty_state/baseline.txt:108:[agent_autonomy] ./verify_model.py:2:from agents.secure_agent import SecureAgent
[agent_autonomy] ./.novelty_state/baseline.txt:109:[agent_autonomy] ./verify_model.py:9:        "Agentic CAP Logic": "agents/secure_agent.py",
[agent_autonomy] ./.novelty_state/baseline.txt:110:[agent_autonomy] ./.vault/logic_blueprints/audit_v2.py:9:from v2_model.agents.secure_agent_v2 import AgentV2
[agent_autonomy] ./.novelty_state/baseline.txt:111:[agent_autonomy] ./.vault/logic_blueprints/audit_v2.py:20:    agent = AgentV2(os.urandom(32))
[agent_autonomy] ./.novelty_state/baseline.txt:112:[agent_autonomy] ./.vault/logic_blueprints/audit_v2.py:21:    print(f"Time-Bounded Policy:     {'✅ ACTIVE' if agent.is_fresh(time.time() - 0.5) else '❌ FAIL'}")
[agent_autonomy] ./.novelty_state/baseline.txt:113:[agent_autonomy] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[agent_autonomy] ./.novelty_state/baseline.txt:114:[agent_autonomy] ./.vault/logic_blueprints/audit_v2.py:25:    print(f"V2 Safety Sink:          {'✅ LOCKED' if agent.locked else '❌ FAIL'}")
[agent_autonomy] ./.novelty_state/baseline.txt:115:[agent_autonomy] ./.novelty_state/current.txt:15:[attack_pressure] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[agent_autonomy] ./.novelty_state/baseline.txt:116:[agent_autonomy] ./.novelty_state/current.txt:16:[attack_pressure] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[agent_autonomy] ./.novelty_state/baseline.txt:117:[agent_autonomy] ./.novelty_state/current.txt:17:[attack_pressure] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[agent_autonomy] ./.novelty_state/baseline.txt:118:[agent_autonomy] ./.novelty_state/current.txt:18:[attack_pressure] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[agent_autonomy] ./.novelty_state/baseline.txt:119:[agent_autonomy] ./.novelty_state/current.txt:19:[attack_pressure] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[agent_autonomy] ./.novelty_state/baseline.txt:120:[agent_autonomy] ./.novelty_state/current.txt:20:[attack_pressure] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[agent_autonomy] ./.novelty_state/baseline.txt:121:[agent_autonomy] ./.novelty_state/current.txt:21:[attack_pressure] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[agent_autonomy] ./.novelty_state/baseline.txt:122:[agent_autonomy] ./.novelty_state/current.txt:24:[attack_pressure] ./agents/secure_agent.py:9:        self.pressure = 0.0
[agent_autonomy] ./.novelty_state/baseline.txt:123:[agent_autonomy] ./.novelty_state/current.txt:25:[attack_pressure] ./agents/secure_agent.py:20:    def add_attack_pressure(self, amount):
[agent_autonomy] ./.novelty_state/baseline.txt:124:[agent_autonomy] ./.novelty_state/current.txt:26:[attack_pressure] ./agents/secure_agent.py:22:        self.pressure += amount
[agent_autonomy] ./.novelty_state/baseline.txt:125:[agent_autonomy] ./.novelty_state/current.txt:27:[attack_pressure] ./agents/secure_agent.py:23:        if self.pressure >= self.PRESSURE_LIMIT:
[agent_autonomy] ./.novelty_state/baseline.txt:126:[agent_autonomy] ./.novelty_state/current.txt:28:[attack_pressure] ./agents/secure_agent.py:25:            print(f"[V1-SECURITY] LOCKOUT TRIGGERED -> Pressure: {self.pressure:.2f}")
[agent_autonomy] ./.novelty_state/baseline.txt:127:[agent_autonomy] ./.novelty_state/current.txt:29:[adaptive_threshold] ./protocol/receiver.py:7:    if len(packets) < agent.threshold:
[agent_autonomy] ./.novelty_state/baseline.txt:128:[agent_autonomy] ./.novelty_state/current.txt:30:[adaptive_threshold] ./protocol/receiver.py:25:    return len(seen) >= agent.threshold
[agent_autonomy] ./.novelty_state/baseline.txt:129:[agent_autonomy] ./.novelty_state/current.txt:32:[adaptive_threshold] ./agents/secure_agent.py:11:        self.threshold = 12
[agent_autonomy] ./.novelty_state/baseline.txt:130:[agent_autonomy] ./.novelty_state/current.txt:33:[adaptive_threshold] ./agents/secure_agent.py:18:        self.threshold = max(4, int(self.fragment_count * (1.0 - loss)))
[agent_autonomy] ./.novelty_state/baseline.txt:131:[agent_autonomy] ./.novelty_state/current.txt:34:[adaptive_threshold] ./agents/learning_agent.py:3:    Online adaptive security agent.
[agent_autonomy] ./.novelty_state/baseline.txt:132:[agent_autonomy] ./.novelty_state/current.txt:35:[agent_autonomy] ./protocol/receiver.py:3:def receive_and_reconstruct(packets, agent):
[agent_autonomy] ./.novelty_state/baseline.txt:133:[agent_autonomy] ./.novelty_state/current.txt:36:[agent_autonomy] ./protocol/receiver.py:4:    if agent.is_locked() or not packets:
[agent_autonomy] ./.novelty_state/baseline.txt:134:[agent_autonomy] ./.novelty_state/current.txt:37:[agent_autonomy] ./protocol/receiver.py:7:    if len(packets) < agent.threshold:
[agent_autonomy] ./.novelty_state/baseline.txt:135:[agent_autonomy] ./.novelty_state/current.txt:38:[agent_autonomy] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[agent_autonomy] ./.novelty_state/baseline.txt:136:[agent_autonomy] ./.novelty_state/current.txt:39:[agent_autonomy] ./protocol/receiver.py:9:        if agent.is_locked():
[agent_autonomy] ./.novelty_state/baseline.txt:137:[agent_autonomy] ./.novelty_state/current.txt:40:[agent_autonomy] ./protocol/receiver.py:17:        key = agent.get_layer_key(p.frag_id)
[agent_autonomy] ./.novelty_state/baseline.txt:138:[agent_autonomy] ./.novelty_state/current.txt:41:[agent_autonomy] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[agent_autonomy] ./.novelty_state/baseline.txt:139:[agent_autonomy] ./.novelty_state/current.txt:42:[agent_autonomy] ./protocol/receiver.py:22:        if agent.is_locked():
[agent_autonomy] ./.novelty_state/baseline.txt:140:[agent_autonomy] ./.novelty_state/current.txt:43:[agent_autonomy] ./protocol/receiver.py:25:    return len(seen) >= agent.threshold
[agent_autonomy] ./.novelty_state/baseline.txt:141:[agent_autonomy] ./.novelty_state/current.txt:44:[agent_autonomy] ./protocol/packet.py:4:    def __init__(self, ciphertext, nonce, tag, cert, timestamp):
[agent_autonomy] ./.novelty_state/baseline.txt:142:[agent_autonomy] ./.novelty_state/current.txt:45:[agent_autonomy] ./protocol/packet.py:5:        self.ciphertext = ciphertext
[agent_autonomy] ./.novelty_state/baseline.txt:143:[agent_autonomy] ./.novelty_state/current.txt:46:[agent_autonomy] ./protocol/packet.py:6:        self.nonce = nonce
[agent_autonomy] ./.novelty_state/baseline.txt:144:[agent_autonomy] ./.novelty_state/current.txt:47:[agent_autonomy] ./protocol/packet.py:7:        self.tag = tag
[agent_autonomy] ./.novelty_state/baseline.txt:145:[agent_autonomy] ./.novelty_state/current.txt:48:[agent_autonomy] ./protocol/packet.py:8:        self.cert = cert
[agent_autonomy] ./.novelty_state/baseline.txt:146:[agent_autonomy] ./.novelty_state/current.txt:49:[agent_autonomy] ./protocol/packet.py:9:        self.timestamp = timestamp
[agent_autonomy] ./.novelty_state/baseline.txt:147:[agent_autonomy] ./.novelty_state/current.txt:50:[agent_autonomy] ./protocol/sender.py:6:def generate_traffic(agent, data, dummy_ratio):
[agent_autonomy] ./.novelty_state/baseline.txt:148:[agent_autonomy] ./.novelty_state/current.txt:51:[agent_autonomy] ./protocol/sender.py:7:    assert hasattr(agent, "fragment_count"), "Agent contract violated"
[agent_autonomy] ./.novelty_state/baseline.txt:149:[agent_autonomy] ./.novelty_state/current.txt:52:[agent_autonomy] ./protocol/sender.py:14:        layer_key = agent.get_layer_key(i)
[agent_autonomy] ./.novelty_state/baseline.txt:150:[agent_autonomy] ./.novelty_state/current.txt:53:[agent_autonomy] ./protocol/sender.py:19:            total_frags=agent.fragment_count,
[agent_autonomy] ./.novelty_state/baseline.txt:151:[agent_autonomy] ./.novelty_state/current.txt:54:[agent_autonomy] ./protocol/sender.py:30:        pkt = Packet(msg_id, i, agent.fragment_count, os.urandom(1))
[agent_autonomy] ./.novelty_state/baseline.txt:152:[agent_autonomy] ./.novelty_state/current.txt:55:[agent_autonomy] ./protocol/sender.py:31:        pkt.signature = signer.sign(pkt.signable(), agent.get_layer_key(i))
[agent_autonomy] ./.novelty_state/baseline.txt:153:[agent_autonomy] ./.novelty_state/current.txt:56:[agent_autonomy] ./simulation/run_experiments.py:4:def run_all(agent, traffic_fn, receiver_fn):
[agent_autonomy] ./.novelty_state/baseline.txt:154:[agent_autonomy] ./.novelty_state/current.txt:57:[agent_autonomy] ./simulation/run_experiments.py:13:            agent.locked = False
[agent_autonomy] ./.novelty_state/baseline.txt:155:[agent_autonomy] ./.novelty_state/current.txt:58:[agent_autonomy] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[agent_autonomy] ./.novelty_state/baseline.txt:156:[agent_autonomy] ./.novelty_state/current.txt:59:[agent_autonomy] ./simulation/run_experiments.py:15:            agent._lock_announced = False
[agent_autonomy] ./.novelty_state/baseline.txt:157:[agent_autonomy] ./.novelty_state/current.txt:60:[agent_autonomy] ./simulation/run_experiments.py:18:            agent.observe(loss)
[agent_autonomy] ./.novelty_state/baseline.txt:158:[agent_autonomy] ./.novelty_state/current.txt:61:[agent_autonomy] ./simulation/run_experiments.py:21:            packets = traffic_fn(agent, b"POWER_GRID_CMD", 0.2)
[agent_autonomy] ./.novelty_state/baseline.txt:159:[agent_autonomy] ./.novelty_state/current.txt:62:[agent_autonomy] ./simulation/run_experiments.py:25:            if agent.is_locked():
[agent_autonomy] ./.novelty_state/baseline.txt:160:[agent_autonomy] ./.novelty_state/current.txt:63:[agent_autonomy] ./simulation/run_experiments.py:27:            elif receiver_fn(packets, agent):
[agent_autonomy] ./.novelty_state/baseline.txt:161:[agent_autonomy] ./.novelty_state/current.txt:64:[agent_autonomy] ./tests/verify_v1.py:4:from agents.secure_agent import SecureAgent
[agent_autonomy] ./.novelty_state/baseline.txt:162:[agent_autonomy] ./.novelty_state/current.txt:65:[agent_autonomy] ./tests/verify_v1.py:19:    agent = SecureAgent(os.urandom(32))
[agent_autonomy] ./.novelty_state/baseline.txt:163:[agent_autonomy] ./.novelty_state/current.txt:66:[agent_autonomy] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[agent_autonomy] ./.novelty_state/baseline.txt:164:[agent_autonomy] ./.novelty_state/current.txt:67:[agent_autonomy] ./tests/verify_v1.py:21:    print(f"Layer 7 (Safety):   {'✅ LOCKED' if agent.is_locked() else '❌ FAIL'}")
[agent_autonomy] ./.novelty_state/baseline.txt:165:[agent_autonomy] ./.novelty_state/current.txt:68:[agent_autonomy] ./tests/verify_final.py:4:from agents.secure_agent import SecureAgent
[agent_autonomy] ./.novelty_state/baseline.txt:166:[agent_autonomy] ./.novelty_state/current.txt:69:[agent_autonomy] ./tests/verify_final.py:24:    agent = SecureAgent(os.urandom(32))
[agent_autonomy] ./.novelty_state/baseline.txt:167:[agent_autonomy] ./.novelty_state/current.txt:70:[agent_autonomy] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[agent_autonomy] ./.novelty_state/baseline.txt:168:[agent_autonomy] ./.novelty_state/current.txt:71:[agent_autonomy] ./tests/verify_v2.py:4:from agents.secure_agent import SecureAgentV2
[agent_autonomy] ./.novelty_state/baseline.txt:169:[agent_autonomy] ./.novelty_state/current.txt:72:[agent_autonomy] ./tests/verify_v2.py:14:    agent = SecureAgentV2(os.urandom(32))
[agent_autonomy] ./.novelty_state/baseline.txt:170:[agent_autonomy] ./.novelty_state/current.txt:73:[agent_autonomy] ./tests/verify_v2.py:16:    print(f"Layer 7 (Time-Freshness):  {'✅ VALID' if agent.is_time_valid(valid_ts) else '❌ FAIL'}")
[agent_autonomy] ./.novelty_state/baseline.txt:171:[agent_autonomy] ./.novelty_state/current.txt:74:[agent_autonomy] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[agent_autonomy] ./.novelty_state/baseline.txt:172:[agent_autonomy] ./.novelty_state/current.txt:75:[agent_autonomy] ./tests/verify_v2.py:19:    print(f"Layer 7 (Safety Sink):     {'✅ LOCKED' if agent.is_locked() else '❌ FAIL'}")
[agent_autonomy] ./.novelty_state/baseline.txt:173:[agent_autonomy] ./.novelty_state/current.txt:76:[agent_autonomy] ./receiver.py:4:    def __init__(self, agent):
[agent_autonomy] ./.novelty_state/baseline.txt:174:[agent_autonomy] ./.novelty_state/current.txt:77:[agent_autonomy] ./receiver.py:5:        self.agent = agent
[agent_autonomy] ./.novelty_state/baseline.txt:175:[agent_autonomy] ./.novelty_state/current.txt:78:[agent_autonomy] ./receiver.py:7:        self.epoch_size = 10
[agent_autonomy] ./.novelty_state/baseline.txt:176:[agent_autonomy] ./.novelty_state/current.txt:79:[agent_autonomy] ./receiver.py:8:        self.epoch_invalid = 0
[agent_autonomy] ./.novelty_state/baseline.txt:177:[agent_autonomy] ./.novelty_state/current.txt:80:[agent_autonomy] ./receiver.py:9:        self.epoch_total = 0
[agent_autonomy] ./.novelty_state/baseline.txt:178:[agent_autonomy] ./.novelty_state/current.txt:81:[agent_autonomy] ./receiver.py:11:        self.bad_epochs = deque(maxlen=3)
[agent_autonomy] ./.novelty_state/baseline.txt:179:[agent_autonomy] ./.novelty_state/current.txt:82:[agent_autonomy] ./r
[agent_autonomy] ./.novelty_state/baseline.txt:180:[agent_autonomy] ./core/crypto.py:10:    def encrypt(self, data: bytes, key: bytes) -> bytes:
[agent_autonomy] ./.novelty_state/baseline.txt:181:[agent_autonomy] ./core/crypto.py:13:    def decrypt(self, data: bytes, key: bytes) -> bytes:
[agent_autonomy] ./.novelty_state/baseline.txt:182:[agent_autonomy] ./core/time_lock.py:10:    def __init__(self, ttl_ms: float):
[agent_autonomy] ./.novelty_state/baseline.txt:183:[agent_autonomy] ./core/time_lock.py:11:        self.ttl_ms = ttl_ms
[agent_autonomy] ./.novelty_state/baseline.txt:184:[agent_autonomy] ./core/time_lock.py:13:    def seal(self, nonce: bytes) -> bytes:
[agent_autonomy] ./.novelty_state/baseline.txt:185:[agent_autonomy] ./core/time_lock.py:17:        expiry_bucket = int(time.time() * 1000 // self.ttl_ms)
[agent_autonomy] ./.novelty_state/baseline.txt:186:[agent_autonomy] ./core/time_lock.py:20:    def verify(self, nonce: bytes, seal: bytes) -> bool:
[agent_autonomy] ./.novelty_state/baseline.txt:187:[agent_autonomy] ./core/time_lock.py:24:        expiry_bucket = int(time.time() * 1000 // self.ttl_ms)
[agent_autonomy] ./.novelty_state/baseline.txt:188:[agent_autonomy] ./core/packet.py:2:    def __init__(self, msg_id, frag_id, total_frags, payload, is_dummy=False, signature=None):
[agent_autonomy] ./.novelty_state/baseline.txt:189:[agent_autonomy] ./core/packet.py:3:        self.msg_id = msg_id
[agent_autonomy] ./.novelty_state/baseline.txt:190:[agent_autonomy] ./core/packet.py:4:        self.frag_id = frag_id
[agent_autonomy] ./.novelty_state/baseline.txt:191:[agent_autonomy] ./core/packet.py:5:        self.total_frags = total_frags
[agent_autonomy] ./.novelty_state/baseline.txt:192:[agent_autonomy] ./core/packet.py:6:        self.payload = payload
[agent_autonomy] ./.novelty_state/baseline.txt:193:[agent_autonomy] ./core/packet.py:7:        self.is_dummy = is_dummy
[agent_autonomy] ./.novelty_state/baseline.txt:194:[agent_autonomy] ./core/packet.py:8:        self.signature = signature
[agent_autonomy] ./.novelty_state/baseline.txt:195:[agent_autonomy] ./core/packet.py:10:    def signable(self):
[agent_autonomy] ./.novelty_state/baseline.txt:196:[agent_autonomy] ./core/packet.py:11:        if self.is_dummy:
[agent_autonomy] ./.novelty_state/baseline.txt:197:[agent_autonomy] ./core/packet.py:12:            return self.msg_id + b"DUMMY"
[agent_autonomy] ./.novelty_state/baseline.txt:198:[agent_autonomy] ./core/packet.py:13:        return self.msg_id + self.frag_id.to_bytes(4, "big") + self.payload
[agent_autonomy] ./.novelty_state/baseline.txt:199:[agent_autonomy] ./core/signature.py:8:    def sign(self, data: bytes, key: bytes) -> bytes:
[agent_autonomy] ./.novelty_state/baseline.txt:200:[agent_autonomy] ./core/signature.py:11:    def verify(self, data: bytes, signature: bytes, key: bytes) -> bool:
[agent_autonomy] ./.novelty_state/baseline.txt:201:[agent_autonomy] ./core/crypto/encryption.py:4:    def __init__(self, key):
[agent_autonomy] ./.novelty_state/baseline.txt:202:[agent_autonomy] ./core/crypto/encryption.py:5:        self.key = key
[agent_autonomy] ./.novelty_state/baseline.txt:203:[agent_autonomy] ./core/crypto/encryption.py:7:    def seal(self, data):
[agent_autonomy] ./.novelty_state/baseline.txt:204:[agent_autonomy] ./core/crypto/encryption.py:9:        cipher = AES.new(self.key, AES.MODE_GCM)
[agent_autonomy] ./.novelty_state/baseline.txt:205:[agent_autonomy] ./core/crypto/encryption.py:13:    def open(self, bundle):
[agent_autonomy] ./.novelty_state/baseline.txt:206:[agent_autonomy] ./core/crypto/encryption.py:16:            cipher = AES.new(self.key, AES.MODE_GCM, nonce=bundle["n"])
[agent_autonomy] ./.novelty_state/baseline.txt:207:[agent_autonomy] ./core/crypto/ca.py:7:    def __init__(self):
[agent_autonomy] ./.novelty_state/baseline.txt:208:[agent_autonomy] ./core/crypto/ca.py:8:        self._key = RSA.generate(2048)
[agent_autonomy] ./.novelty_state/baseline.txt:209:[agent_autonomy] ./core/crypto/ca.py:9:        self.public_key = self._key.publickey()
[agent_autonomy] ./.novelty_state/baseline.txt:210:[agent_autonomy] ./core/crypto/ca.py:11:    def sign(self, data: bytes) -> bytes:
[agent_autonomy] ./.novelty_state/baseline.txt:211:[agent_autonomy] ./core/crypto/ca.py:13:        return pkcs1_15.new(self._key).sign(h)
[agent_autonomy] ./.novelty_state/baseline.txt:212:[agent_autonomy] ./core/crypto/ca.py:15:    def verify(self, data: bytes, signature: bytes) -> bool:
[agent_autonomy] ./.novelty_state/baseline.txt:213:[agent_autonomy] ./core/crypto/ca.py:18:            pkcs1_15.new(self.public_key).verify(h, signature)
[agent_autonomy] ./.novelty_state/baseline.txt:214:[agent_autonomy] ./agents/receiver_agent.py:2:    def verify(self, packets):
[agent_autonomy] ./.novelty_state/baseline.txt:215:[agent_autonomy] ./agents/receiver_agent.py:4:receiver_agent.py
[agent_autonomy] ./.novelty_state/baseline.txt:216:[agent_autonomy] ./agents/secure_agent.py:6:    def __init__(self, master_key):
[agent_autonomy] ./.novelty_state/baseline.txt:217:[agent_autonomy] ./agents/secure_agent.py:7:        self.master_key = master_key
[agent_autonomy] ./.novelty_state/baseline.txt:218:[agent_autonomy] ./agents/secure_agent.py:8:        self.locked = False
[agent_autonomy] ./.novelty_state/baseline.txt:219:[agent_autonomy] ./agents/secure_agent.py:9:        self.pressure = 0.0
[agent_autonomy] ./.novelty_state/baseline.txt:220:[agent_autonomy] ./agents/secure_agent.py:10:        self.fragment_count = 12 
[agent_autonomy] ./.novelty_state/baseline.txt:221:[agent_autonomy] ./agents/secure_agent.py:11:        self.threshold = 12
[agent_autonomy] ./.novelty_state/baseline.txt:222:[agent_autonomy] ./agents/secure_agent.py:13:    def is_locked(self):
[agent_autonomy] ./.novelty_state/baseline.txt:223:[agent_autonomy] ./agents/secure_agent.py:14:        return self.locked
[agent_autonomy] ./.novelty_state/baseline.txt:224:[agent_autonomy] ./agents/secure_agent.py:16:    def observe(self, loss):
[agent_autonomy] ./.novelty_state/baseline.txt:225:[agent_autonomy] ./agents/secure_agent.py:17:        if self.locked: return
[agent_autonomy] ./.novelty_state/baseline.txt:226:[agent_autonomy] ./agents/secure_agent.py:18:        self.threshold = max(4, int(self.fragment_count * (1.0 - loss)))
[agent_autonomy] ./.novelty_state/baseline.txt:227:[agent_autonomy] ./agents/secure_agent.py:20:    def add_attack_pressure(self, amount):
[agent_autonomy] ./.novelty_state/baseline.txt:228:[agent_autonomy] ./agents/secure_agent.py:21:        if self.locked: return
[agent_autonomy] ./.novelty_state/baseline.txt:229:[agent_autonomy] ./agents/secure_agent.py:22:        self.pressure += amount
[agent_autonomy] ./.novelty_state/baseline.txt:230:[agent_autonomy] ./agents/secure_agent.py:23:        if self.pressure >= self.PRESSURE_LIMIT:
[agent_autonomy] ./.novelty_state/baseline.txt:231:[agent_autonomy] ./agents/secure_agent.py:24:            self.locked = True
[agent_autonomy] ./.novelty_state/baseline.txt:232:[agent_autonomy] ./agents/secure_agent.py:25:            print(f"[V1-SECURITY] LOCKOUT TRIGGERED -> Pressure: {self.pressure:.2f}")
[agent_autonomy] ./.novelty_state/baseline.txt:233:[agent_autonomy] ./agents/secure_agent.py:27:    def get_layer_key(self, layer_id):
[agent_autonomy] ./.novelty_state/baseline.txt:234:[agent_autonomy] ./agents/secure_agent.py:28:        return hashlib.sha256(self.master_key + str(layer_id).encode()).digest()
[agent_autonomy] ./.novelty_state/baseline.txt:235:[agent_autonomy] ./agents/sender_agent.py:2:    def adapt(self, threat_level):
[agent_autonomy] ./.novelty_state/baseline.txt:236:[agent_autonomy] ./agents/network_agent.py:2:    def observe(self, congestion, loss, flood):
[agent_autonomy] ./.novelty_state/baseline.txt:237:[agent_autonomy] ./agents/learning_agent.py:3:    Online adaptive security agent.
[agent_autonomy] ./.novelty_state/baseline.txt:238:[agent_autonomy] ./agents/learning_agent.py:8:    def __init__(self):
[agent_autonomy] ./.novelty_state/baseline.txt:239:[agent_autonomy] ./agents/learning_agent.py:9:        self.loss_ema = 0.0
[agent_autonomy] ./.novelty_state/baseline.txt:240:[agent_autonomy] ./agents/learning_agent.py:10:        self.delay_ema = 0.0
[agent_autonomy] ./.novelty_state/baseline.txt:241:[agent_autonomy] ./agents/learning_agent.py:11:        self.alpha = 0.2  # learning rate
[agent_autonomy] ./.novelty_state/baseline.txt:242:[agent_autonomy] ./agents/learning_agent.py:13:        self.fragment_count = 8
[agent_autonomy] ./.novelty_state/baseline.txt:243:[agent_autonomy] ./agents/learning_agent.py:14:        self.dummy_ratio = 1.0
[agent_autonomy] ./.novelty_state/baseline.txt:244:[agent_autonomy] ./agents/learning_agent.py:16:    def observe(self, loss, delay):
[agent_autonomy] ./.novelty_state/baseline.txt:245:[agent_autonomy] ./agents/learning_agent.py:17:        self.loss_ema = (1 - self.alpha) * self.loss_ema + self.alpha * loss
[agent_autonomy] ./.novelty_state/baseline.txt:246:[agent_autonomy] ./agents/learning_agent.py:18:        self.delay_ema = (1 - self.alpha) * self.delay_ema + self.alpha * delay
[agent_autonomy] ./.novelty_state/baseline.txt:247:[agent_autonomy] ./agents/learning_agent.py:20:    def act(self):
[agent_autonomy] ./.novelty_state/baseline.txt:248:[agent_autonomy] ./agents/learning_agent.py:21:        threat = min(1.0, self.loss_ema + self.delay_ema)
[agent_autonomy] ./.novelty_state/baseline.txt:249:[agent_autonomy] ./agents/learning_agent.py:24:        self.fragment_count = 8 + int(6 * threat)
[agent_autonomy] ./.novelty_state/baseline.txt:250:[agent_autonomy] ./agents/learning_agent.py:25:        self.dummy_ratio = 1.0 + 2.0 * threat
[agent_autonomy] ./.novelty_state/baseline.txt:251:[agent_autonomy] ./agents/learning_agent.py:27:        return self.fragment_count, self.dummy_ratio
[agent_autonomy] ./.novelty_state/baseline.txt:252:[agent_autonomy] ./v2_model/agents/secure_agent_v2.py:5:    def __init__(self, key):
[agent_autonomy] ./.novelty_state/baseline.txt:253:[agent_autonomy] ./v2_model/agents/secure_agent_v2.py:6:        self.key = key
[agent_autonomy] ./.novelty_state/baseline.txt:254:[agent_autonomy] ./v2_model/agents/secure_agent_v2.py:7:        self.locked = False
[agent_autonomy] ./.novelty_state/baseline.txt:255:[agent_autonomy] ./v2_model/agents/secure_agent_v2.py:8:    def is_fresh(self, ts):
[agent_autonomy] ./.novelty_state/baseline.txt:256:[agent_autonomy] ./v2_model/agents/secure_agent_v2.py:9:        return (time.time() - ts) < self.TIME_WINDOW
[agent_autonomy] ./.novelty_state/current.txt:29:[attack_pressure] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[agent_autonomy] ./.novelty_state/current.txt:30:[attack_pressure] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[agent_autonomy] ./.novelty_state/current.txt:31:[attack_pressure] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[agent_autonomy] ./.novelty_state/current.txt:32:[attack_pressure] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[agent_autonomy] ./.novelty_state/current.txt:33:[attack_pressure] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[agent_autonomy] ./.novelty_state/current.txt:34:[attack_pressure] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[agent_autonomy] ./.novelty_state/current.txt:35:[attack_pressure] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[agent_autonomy] ./.novelty_state/current.txt:36:[attack_pressure] ./.novelty_state/baseline.txt:15:[attack_pressure] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[agent_autonomy] ./.novelty_state/current.txt:37:[attack_pressure] ./.novelty_state/baseline.txt:16:[attack_pressure] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[agent_autonomy] ./.novelty_state/current.txt:38:[attack_pressure] ./.novelty_state/baseline.txt:17:[attack_pressure] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[agent_autonomy] ./.novelty_state/current.txt:39:[attack_pressure] ./.novelty_state/baseline.txt:18:[attack_pressure] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[agent_autonomy] ./.novelty_state/current.txt:40:[attack_pressure] ./.novelty_state/baseline.txt:19:[attack_pressure] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[agent_autonomy] ./.novelty_state/current.txt:41:[attack_pressure] ./.novelty_state/baseline.txt:20:[attack_pressure] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[agent_autonomy] ./.novelty_state/current.txt:42:[attack_pressure] ./.novelty_state/baseline.txt:21:[attack_pressure] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[agent_autonomy] ./.novelty_state/current.txt:45:[attack_pressure] ./.novelty_state/baseline.txt:24:[attack_pressure] ./agents/secure_agent.py:9:        self.pressure = 0.0
[agent_autonomy] ./.novelty_state/current.txt:46:[attack_pressure] ./.novelty_state/baseline.txt:25:[attack_pressure] ./agents/secure_agent.py:20:    def add_attack_pressure(self, amount):
[agent_autonomy] ./.novelty_state/current.txt:47:[attack_pressure] ./.novelty_state/baseline.txt:26:[attack_pressure] ./agents/secure_agent.py:22:        self.pressure += amount
[agent_autonomy] ./.novelty_state/current.txt:48:[attack_pressure] ./.novelty_state/baseline.txt:27:[attack_pressure] ./agents/secure_agent.py:23:        if self.pressure >= self.PRESSURE_LIMIT:
[agent_autonomy] ./.novelty_state/current.txt:49:[attack_pressure] ./.novelty_state/baseline.txt:28:[attack_pressure] ./agents/secure_agent.py:25:            print(f"[V1-SECURITY] LOCKOUT TRIGGERED -> Pressure: {self.pressure:.2f}")
[agent_autonomy] ./.novelty_state/current.txt:50:[attack_pressure] ./.novelty_state/baseline.txt:38:[agent_autonomy] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[agent_autonomy] ./.novelty_state/current.txt:51:[attack_pressure] ./.novelty_state/baseline.txt:41:[agent_autonomy] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[agent_autonomy] ./.novelty_state/current.txt:52:[attack_pressure] ./.novelty_state/baseline.txt:58:[agent_autonomy] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[agent_autonomy] ./.novelty_state/current.txt:53:[attack_pressure] ./.novelty_state/baseline.txt:66:[agent_autonomy] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[agent_autonomy] ./.novelty_state/current.txt:54:[attack_pressure] ./.novelty_state/baseline.txt:70:[agent_autonomy] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[agent_autonomy] ./.novelty_state/current.txt:55:[attack_pressure] ./.novelty_state/baseline.txt:74:[agent_autonomy] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[agent_autonomy] ./.novelty_state/current.txt:56:[attack_pressure] ./.novelty_state/baseline.txt:113:[agent_autonomy] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[agent_autonomy] ./.novelty_state/current.txt:57:[attack_pressure] ./.novelty_state/baseline.txt:115:[agent_autonomy] ./.novelty_state/current.txt:15:[attack_pressure] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[agent_autonomy] ./.novelty_state/current.txt:58:[attack_pressure] ./.novelty_state/baseline.txt:116:[agent_autonomy] ./.novelty_state/current.txt:16:[attack_pressure] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[agent_autonomy] ./.novelty_state/current.txt:59:[attack_pressure] ./.novelty_state/baseline.txt:117:[agent_autonomy] ./.novelty_state/current.txt:17:[attack_pressure] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[agent_autonomy] ./.novelty_state/current.txt:60:[attack_pressure] ./.novelty_state/baseline.txt:118:[agent_autonomy] ./.novelty_state/current.txt:18:[attack_pressure] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[agent_autonomy] ./.novelty_state/current.txt:61:[attack_pressure] ./.novelty_state/baseline.txt:119:[agent_autonomy] ./.novelty_state/current.txt:19:[attack_pressure] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[agent_autonomy] ./.novelty_state/current.txt:62:[attack_pressure] ./.novelty_state/baseline.txt:120:[agent_autonomy] ./.novelty_state/current.txt:20:[attack_pressure] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[agent_autonomy] ./.novelty_state/current.txt:63:[attack_pressure] ./.novelty_state/baseline.txt:121:[agent_autonomy] ./.novelty_state/current.txt:21:[attack_pressure] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[agent_autonomy] ./.novelty_state/current.txt:64:[attack_pressure] ./.novelty_state/baseline.txt:122:[agent_autonomy] ./.novelty_state/current.txt:24:[attack_pressure] ./agents/secure_agent.py:9:        self.pressure = 0.0
[agent_autonomy] ./.novelty_state/current.txt:65:[attack_pressure] ./.novelty_state/baseline.txt:123:[agent_autonomy] ./.novelty_state/current.txt:25:[attack_pressure] ./agents/secure_agent.py:20:    def add_attack_pressure(self, amount):
[agent_autonomy] ./.novelty_state/current.txt:66:[attack_pressure] ./.novelty_state/baseline.txt:124:[agent_autonomy] ./.novelty_state/current.txt:26:[attack_pressure] ./agents/secure_agent.py:22:        self.pressure += amount
[agent_autonomy] ./.novelty_state/current.txt:67:[attack_pressure] ./.novelty_state/baseline.txt:125:[agent_autonomy] ./.novelty_state/current.txt:27:[attack_pressure] ./agents/secure_agent.py:23:        if self.pressure >= self.PRESSURE_LIMIT:
[agent_autonomy] ./.novelty_state/current.txt:68:[attack_pressure] ./.novelty_state/baseline.txt:126:[agent_autonomy] ./.novelty_state/current.txt:28:[attack_pressure] ./agents/secure_agent.py:25:            print(f"[V1-SECURITY] LOCKOUT TRIGGERED -> Pressure: {self.pressure:.2f}")
[agent_autonomy] ./.novelty_state/current.txt:69:[attack_pressure] ./.novelty_state/baseline.txt:135:[agent_autonomy] ./.novelty_state/current.txt:38:[agent_autonomy] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[agent_autonomy] ./.novelty_state/current.txt:70:[attack_pressure] ./.novelty_state/baseline.txt:138:[agent_autonomy] ./.novelty_state/current.txt:41:[agent_autonomy] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[agent_autonomy] ./.novelty_state/current.txt:71:[attack_pressure] ./.novelty_state/baseline.txt:155:[agent_autonomy] ./.novelty_state/current.txt:58:[agent_autonomy] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[agent_autonomy] ./.novelty_state/current.txt:72:[attack_pressure] ./.novelty_state/baseline.txt:163:[agent_autonomy] ./.novelty_state/current.txt:66:[agent_autonomy] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[agent_autonomy] ./.novelty_state/current.txt:73:[attack_pressure] ./.novelty_state/baseline.txt:167:[agent_autonomy] ./.novelty_state/current.txt:70:[agent_autonomy] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[agent_autonomy] ./.novelty_state/current.txt:74:[attack_pressure] ./.novelty_state/baseline.txt:171:[agent_autonomy] ./.novelty_state/current.txt:74:[agent_autonomy] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[agent_autonomy] ./.novelty_state/current.txt:75:[attack_pressure] ./.novelty_state/baseline.txt:219:[agent_autonomy] ./agents/secure_agent.py:9:        self.pressure = 0.0
[agent_autonomy] ./.novelty_state/current.txt:76:[attack_pressure] ./.novelty_state/baseline.txt:227:[agent_autonomy] ./agents/secure_agent.py:20:    def add_attack_pressure(self, amount):
[agent_autonomy] ./.novelty_state/current.txt:77:[attack_pressure] ./.novelty_state/baseline.txt:229:[agent_autonomy] ./agents/secure_agent.py:22:        self.pressure += amount
[agent_autonomy] ./.novelty_state/current.txt:78:[attack_pressure] ./.novelty_state/baseline.txt:230:[agent_autonomy] ./agents/secure_agent.py:23:        if self.pressure >= self.PRESSURE_LIMIT:
[agent_autonomy] ./.novelty_state/current.txt:79:[attack_pressure] ./.novelty_state/baseline.txt:232:[agent_autonomy] ./agents/secure_agent.py:25:            print(f"[V1-SECURITY] LOCKOUT TRIGGERED -> Pressure: {self.pressure:.2f}")
[agent_autonomy] ./.novelty_state/current.txt:80:[attack_pressure] ./.novelty_state/current.txt:29:[attack_pressure] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[agent_autonomy] ./.novelty_state/current.txt:81:[attack_pressure] ./.novelty_state/current.txt:30:[attack_pressure] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[agent_autonomy] ./.novelty_state/current.txt:82:[attack_pressure] ./.novelty_state/current.txt:31:[attack_pressure] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[agent_autonomy] ./.novelty_state/current.txt:83:[attack_pressure] ./.novelty_state/current.txt:32:[attack_pressure] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[agent_autonomy] ./.novelty_state/current.txt:84:[attack_pressure] ./.novelty_state/current.txt:33:[attack_pressure] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[agent_autonomy] ./.novelty_state/current.txt:85:[attack_pressure] ./.novelty_state/current.txt:34:[attack_pressure] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[agent_autonomy] ./.novelty_state/current.txt:86:[attack_pressure] ./.novelty_state/current.txt:35:[attack_pressure] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[agent_autonomy] ./.novelty_state/current.txt:87:[attack_pressure] ./.novelty_state/current.txt:36:[attack_pressure] ./.novelty_state/baseline.txt:15:[attack_pressure] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[agent_autonomy] ./.novelty_state/current.txt:88:[attack_pressure] ./.novelty_state/current.txt:37:[attack_pressure] ./.novelty_state/baseline.txt:16:[attack_pressure] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[agent_autonomy] ./.novelty_state/current.txt:89:[attack_pressure] ./.novelty_state/current.txt:38:[attack_pressure] ./.novelty_state/baseline.txt:17:[attack_pressure] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[agent_autonomy] ./.novelty_state/current.txt:90:[attack_pressure] ./.novelty_state/current.txt:39:[attack_pressure] ./.novelty_state/baseline.txt:18:[attack_pressure] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[agent_autonomy] ./.novelty_state/current.txt:91:[attack_pressure] ./.novelty_state/current.txt:40:[attack_pressure] ./.novelty_state/baseline.txt:19:[attack_pressure] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[agent_autonomy] ./.novelty_state/current.txt:92:[attack_pressure] ./.novelty_state/current.txt:41:[attack_pressure] ./.novelty_state/baseline.txt:20:[attack_pressure] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[agent_autonomy] ./.novelty_state/current.txt:93:[attack_pressure] ./.novelty_state/current.txt:42:[attack_pressure] ./.novelty_state/baseline.txt:21:[attack_pressure] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[agent_autonomy] ./.novelty_state/current.txt:96:[attack_pressure] ./.novelty_state/current.txt:45:[attack_pressure] ./.novelty_state/baseline.txt:24:[attack_pressure] ./agents/secure_agent.py:9:        self.pressure = 0.0
[agent_autonomy] ./.novelty_state/current.txt:97:[attack_pressure] ./.novelty_state/current.txt:46:[attack_pressure] ./.novelty_state/baseline.txt:25:[attack_pressure] ./agents/secure_agent.py:20:    def add_attack_pressure(self, amount):
[agent_autonomy] ./.novelty_state/current.txt:98:[attack_pressure] ./.novelty_state/current.txt:47:[attack_pressure] ./.novelty_state/baseline.txt:26:[attack_pressure] ./agents/secure_agent.py:22:        self.pressure += amount
[agent_autonomy] ./.novelty_state/current.txt:99:[attack_pressure] ./.novelty_state/current.txt:48:[attack_pressure] ./.novelty_state/baseline.txt:27:[attack_pressure] ./agents/secure_agent.py:23:        if self.pressure >= self.PRESSURE_LIMIT:
[agent_autonomy] ./.novelty_state/current.txt:100:[attack_pressure] ./.novelty_state/current.txt:49:[attack_pressure] ./.novelty_state/baseline.txt:28:[attack_pressure] ./agents/secure_agent.py:25:            print(f"[V1-SECURITY] LOCKOUT TRIGGERED -> Pressure: {self.pressure:.2f}")
[agent_autonomy] ./.novelty_state/current.txt:101:[attack_pressure] ./.novelty_state/current.txt:50:[attack_pressure] ./.novelty_state/baseline.txt:38:[agent_autonomy] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[agent_autonomy] ./.novelty_state/current.txt:102:[attack_pressure] ./.novelty_state/current.txt:51:[attack_pressure] ./.novelty_state/baseline.txt:41:[agent_autonomy] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[agent_autonomy] ./.novelty_state/current.txt:103:[attack_pressure] ./.novelty_state/current.txt:52:[attack_pressure] ./.novelty_state/baseline.txt:58:[agent_autonomy] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[agent_autonomy] ./.novelty_state/current.txt:104:[attack_pressure] ./.novelty_state/current.txt:53:[attack_pressure] ./.novelty_state/baseline.txt:66:[agent_autonomy] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[agent_autonomy] ./.novelty_state/current.txt:105:[attack_pressure] ./.novelty_state/current.txt:54:[attack_pressure] ./.novelty_state/baseline.txt:70:[agent_autonomy] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[agent_autonomy] ./.novelty_state/current.txt:106:[attack_pressure] ./.novelty_state/current.txt:55:[attack_pressure] ./.novelty_state/baseline.txt:74:[agent_autonomy] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[agent_autonomy] ./.novelty_state/current.txt:107:[attack_pressure] ./.novelty_state/current.txt:56:[attack_pressure] ./.novelty_state/baseline.txt:113:[agent_autonomy] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[agent_autonomy] ./.novelty_state/current.txt:108:[attack_pressure] ./.novelty_state/current.txt:57:[attack_pressure] ./.novelty_state/baseline.txt:115:[agent_autonomy] ./.novelty_state/current.txt:15:[attack_pressure] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[agent_autonomy] ./.novelty_state/current.txt:109:[attack_pressure] ./.novelty_state/current.txt:58:[attack_pressure] ./.novelty_state/baseline.txt:116:[agent_autonomy] ./.novelty_state/current.txt:16:[attack_pressure] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[agent_autonomy] ./.novelty_state/current.txt:110:[attack_pressure] ./.novelty_state/current.txt:59:[attack_pressure] ./.novelty_state/baseline.txt:117:[agent_autonomy] ./.novelty_state/current.txt:17:[attack_pressure] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[agent_autonomy] ./.novelty_state/current.txt:111:[attack_pressure] ./.novelty_state/current.txt:60:[attack_pressure] ./.novelty_state/baseline.txt:118:[agent_autonomy] ./.novelty_state/current.txt:18:[attack_pressure] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[agent_autonomy] ./.novelty_state/current.txt:112:[attack_pressure] ./.novelty_state/current.txt:61:[attack_pressure] ./.novelty_state/baseline.txt:119:[agent_autonomy] ./.novelty_state/current.txt:19:[attack_pressure] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[agent_autonomy] ./.novelty_state/current.txt:113:[attack_pressure] ./.novelty_state/current.txt:62:[attack_pressure] ./.novelty_state/baseline.txt:120:[agent_autonomy] ./.novelty_state/current.txt:20:[attack_pressure] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[agent_autonomy] ./.novelty_state/current.txt:114:[attack_pressure] ./.novelty_state/current.txt:63:[attack_pressure] ./.novelty_state/baseline.txt:121:[agent_autonomy] ./.novelty_state/current.txt:21:[attack_pressure] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[agent_autonomy] ./.novelty_state/current.txt:115:[attack_pressure] ./.novelty_state/current.txt:64:[attack_pressure] ./.novelty_state/baseline.txt:122:[agent_autonomy] ./.novelty_state/current.txt:24:[attack_pressure] ./agents/secure_agent.py:9:        self.pressure = 0.0
[agent_autonomy] ./.novelty_state/current.txt:116:[attack_pressure] ./.novelty_state/current.txt:65:[attack_pressure] ./.novelty_state/baseline.txt:123:[agent_autonomy] ./.novelty_state/current.txt:25:[attack_pressure] ./agents/secure_agent.py:20:    def add_attack_pressure(self, amount):
[agent_autonomy] ./.novelty_state/current.txt:117:[attack_pressure] ./.novelty_state/current.txt:66:[attack_pressure] ./.novelty_state/baseline.txt:124:[agent_autonomy] ./.novelty_state/current.txt:26:[attack_pressure] ./agents/secure_agent.py:22:        self.pressure += amount
[agent_autonomy] ./.novelty_state/current.txt:118:[attack_pressure] ./.novelty_state/current.txt:67:[attack_pressure] ./.novelty_state/baseline.txt:125:[agent_autonomy] ./.novelty_state/current.txt:27:[attack_pressure] ./agents/secure_agent.py:23:        if self.pressure >= self.PRESSURE_LIMIT:
[agent_autonomy] ./.novelty_state/current.txt:119:[attack_pressure] ./.novelty_state/current.txt:68:[attack_pressure] ./.novelty_state/baseline.txt:126:[agent_autonomy] ./.novelty_state/current.txt:28:[attack_pressure] ./agents/secure_agent.py:25:            print(f"[V1-SECURITY] LOCKOUT TRIGGERED -> Pressure: {self.pressure:.2f}")
[agent_autonomy] ./.novelty_state/current.txt:120:[attack_pressure] ./.novelty_state/current.txt:69:[attack_pressure] ./.novelty_state/baseline.txt:135:[agent_autonomy] ./.novelty_state/current.txt:38:[agent_autonomy] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[agent_autonomy] ./.novelty_state/current.txt:121:[attack_pressure] ./.novelty_state/current.txt:70:[attack_pressure] ./.novelty_state/baseline.txt:138:[agent_autonomy] ./.novelty_state/current.txt:41:[agent_autonomy] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[agent_autonomy] ./.novelty_state/current.txt:122:[attack_pressure] ./.novelty_state/current.txt:71:[attack_pressure] ./.novelty_state/baseline.txt:155:[agent_autonomy] ./.novelty_state/current.txt:58:[agent_autonomy] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[agent_autonomy] ./.novelty_state/current.txt:123:[attack_pressure] ./.novelty_state/current.txt:72:[attack_pressure] ./.novelty_state/baseline.txt:163:[agent_autonomy] ./.novelty_state/current.txt:66:[agent_autonomy] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[agent_autonomy] ./.novelty_state/current.txt:124:[attack_pressure] ./.novelty_state/current.txt:73:[attack_pressure] ./.novelty_state/baseline.txt:167:[agent_autonomy] ./.novelty_state/current.txt:70:[agent_autonomy] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[agent_autonomy] ./.novelty_state/current.txt:125:[attack_pressure] ./.novelty_state/current.txt:74:[attack_pressure] ./.novelty_state/baseline.txt:171:[agent_autonomy] ./.novelty_state/current.txt:74:[agent_autonomy] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[agent_autonomy] ./.novelty_state/current.txt:126:[attack_pressure] ./.novelty_state/current.txt:75:[attack_pressure] ./.novelty_state/baseline.txt:219:[agent_autonomy] ./agents/secure_agent.py:9:        self.pressure = 0.0
[agent_autonomy] ./.novelty_state/current.txt:127:[attack_pressure] ./.novelty_state/current.txt:76:[attack_pressure] ./.novelty_state/baseline.txt:227:[agent_autonomy] ./agents/secure_agent.py:20:    def add_attack_pressure(self, amount):
[agent_autonomy] ./.novelty_state/current.txt:128:[attack_pressure] ./.novelty_state/current.txt:77:[attack_pressure] ./.novelty_state/baseline.txt:229:[agent_autonomy] ./agents/secure_agent.py:22:        self.pressure += amount
[agent_autonomy] ./.novelty_state/current.txt:129:[attack_pressure] ./.novelty_state/current.txt:78:[attack_pressure] ./.novelty_state/baseline.txt:230:[agent_autonomy] ./agents/secure_agent.py:23:        if self.pressure >= self.PRESSURE_LIMIT:
[agent_autonomy] ./.novelty_state/current.txt:130:[attack_pressure] ./.novelty_state/current.txt:79:[attack_pressure] ./.novelty_state/baseline.txt:232:[agent_autonomy] ./agents/secure_agent.py:25:            print(f"[V1-SECURITY] LOCKOUT TRIGGERED -> Pressure: {self.pressure:.2f}")
[agent_autonomy] ./.novelty_state/current.txt:131:[attack_pressure] ./.novelty_state/current.txt:80:[attack_pressure] ./.novelty_state/current.txt:29:[attack_pressure] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[agent_autonomy] ./.novelty_state/current.txt:132:[attack_pressure] ./.novelty_state/current.txt:81:[attack_pressure] ./.novelty_state/current.txt:30:[attack_pressure] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[agent_autonomy] ./.novelty_state/current.txt:133:[attack_pressure] ./.novelty_state/current.txt:82:[attack_pressure] ./.novelty_state/current.txt:31:[attack_pressure] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[agent_autonomy] ./.novelty_state/current.txt:134:[attack_pressure] ./.novelty_state/current.txt:83:[attack_pressure] ./.novelty_state/current.txt:32:[attack_pressure] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10
[agent_autonomy] ./.novelty_state/current.txt:137:[attack_pressure] ./agents/secure_agent.py:9:        self.pressure = 0.0
[agent_autonomy] ./.novelty_state/current.txt:138:[attack_pressure] ./agents/secure_agent.py:20:    def add_attack_pressure(self, amount):
[agent_autonomy] ./.novelty_state/current.txt:139:[attack_pressure] ./agents/secure_agent.py:22:        self.pressure += amount
[agent_autonomy] ./.novelty_state/current.txt:140:[attack_pressure] ./agents/secure_agent.py:23:        if self.pressure >= self.PRESSURE_LIMIT:
[agent_autonomy] ./.novelty_state/current.txt:141:[attack_pressure] ./agents/secure_agent.py:25:            print(f"[V1-SECURITY] LOCKOUT TRIGGERED -> Pressure: {self.pressure:.2f}")
[agent_autonomy] ./.novelty_state/current.txt:142:[adaptive_threshold] ./protocol/receiver.py:7:    if len(packets) < agent.threshold:
[agent_autonomy] ./.novelty_state/current.txt:143:[adaptive_threshold] ./protocol/receiver.py:25:    return len(seen) >= agent.threshold
[agent_autonomy] ./.novelty_state/current.txt:145:[adaptive_threshold] ./.novelty_state/baseline.txt:29:[adaptive_threshold] ./protocol/receiver.py:7:    if len(packets) < agent.threshold:
[agent_autonomy] ./.novelty_state/current.txt:146:[adaptive_threshold] ./.novelty_state/baseline.txt:30:[adaptive_threshold] ./protocol/receiver.py:25:    return len(seen) >= agent.threshold
[agent_autonomy] ./.novelty_state/current.txt:148:[adaptive_threshold] ./.novelty_state/baseline.txt:32:[adaptive_threshold] ./agents/secure_agent.py:11:        self.threshold = 12
[agent_autonomy] ./.novelty_state/current.txt:149:[adaptive_threshold] ./.novelty_state/baseline.txt:33:[adaptive_threshold] ./agents/secure_agent.py:18:        self.threshold = max(4, int(self.fragment_count * (1.0 - loss)))
[agent_autonomy] ./.novelty_state/current.txt:150:[adaptive_threshold] ./.novelty_state/baseline.txt:34:[adaptive_threshold] ./agents/learning_agent.py:3:    Online adaptive security agent.
[agent_autonomy] ./.novelty_state/current.txt:151:[adaptive_threshold] ./.novelty_state/baseline.txt:37:[agent_autonomy] ./protocol/receiver.py:7:    if len(packets) < agent.threshold:
[agent_autonomy] ./.novelty_state/current.txt:152:[adaptive_threshold] ./.novelty_state/baseline.txt:43:[agent_autonomy] ./protocol/receiver.py:25:    return len(seen) >= agent.threshold
[agent_autonomy] ./.novelty_state/current.txt:153:[adaptive_threshold] ./.novelty_state/baseline.txt:127:[agent_autonomy] ./.novelty_state/current.txt:29:[adaptive_threshold] ./protocol/receiver.py:7:    if len(packets) < agent.threshold:
[agent_autonomy] ./.novelty_state/current.txt:154:[adaptive_threshold] ./.novelty_state/baseline.txt:128:[agent_autonomy] ./.novelty_state/current.txt:30:[adaptive_threshold] ./protocol/receiver.py:25:    return len(seen) >= agent.threshold
[agent_autonomy] ./.novelty_state/current.txt:155:[adaptive_threshold] ./.novelty_state/baseline.txt:129:[agent_autonomy] ./.novelty_state/current.txt:32:[adaptive_threshold] ./agents/secure_agent.py:11:        self.threshold = 12
[agent_autonomy] ./.novelty_state/current.txt:156:[adaptive_threshold] ./.novelty_state/baseline.txt:130:[agent_autonomy] ./.novelty_state/current.txt:33:[adaptive_threshold] ./agents/secure_agent.py:18:        self.threshold = max(4, int(self.fragment_count * (1.0 - loss)))
[agent_autonomy] ./.novelty_state/current.txt:157:[adaptive_threshold] ./.novelty_state/baseline.txt:131:[agent_autonomy] ./.novelty_state/current.txt:34:[adaptive_threshold] ./agents/learning_agent.py:3:    Online adaptive security agent.
[agent_autonomy] ./.novelty_state/current.txt:158:[adaptive_threshold] ./.novelty_state/baseline.txt:134:[agent_autonomy] ./.novelty_state/current.txt:37:[agent_autonomy] ./protocol/receiver.py:7:    if len(packets) < agent.threshold:
[agent_autonomy] ./.novelty_state/current.txt:159:[adaptive_threshold] ./.novelty_state/baseline.txt:140:[agent_autonomy] ./.novelty_state/current.txt:43:[agent_autonomy] ./protocol/receiver.py:25:    return len(seen) >= agent.threshold
[agent_autonomy] ./.novelty_state/current.txt:160:[adaptive_threshold] ./.novelty_state/baseline.txt:221:[agent_autonomy] ./agents/secure_agent.py:11:        self.threshold = 12
[agent_autonomy] ./.novelty_state/current.txt:161:[adaptive_threshold] ./.novelty_state/baseline.txt:226:[agent_autonomy] ./agents/secure_agent.py:18:        self.threshold = max(4, int(self.fragment_count * (1.0 - loss)))
[agent_autonomy] ./.novelty_state/current.txt:162:[adaptive_threshold] ./.novelty_state/baseline.txt:237:[agent_autonomy] ./agents/learning_agent.py:3:    Online adaptive security agent.
[agent_autonomy] ./.novelty_state/current.txt:163:[adaptive_threshold] ./agents/secure_agent.py:11:        self.threshold = 12
[agent_autonomy] ./.novelty_state/current.txt:164:[adaptive_threshold] ./agents/secure_agent.py:18:        self.threshold = max(4, int(self.fragment_count * (1.0 - loss)))
[agent_autonomy] ./.novelty_state/current.txt:165:[adaptive_threshold] ./agents/learning_agent.py:3:    Online adaptive security agent.
[agent_autonomy] ./core/crypto.py:10:    def encrypt(self, data: bytes, key: bytes) -> bytes:
[agent_autonomy] ./core/crypto.py:13:    def decrypt(self, data: bytes, key: bytes) -> bytes:
[agent_autonomy] ./core/time_lock.py:10:    def __init__(self, ttl_ms: float):
[agent_autonomy] ./core/time_lock.py:11:        self.ttl_ms = ttl_ms
[agent_autonomy] ./core/time_lock.py:13:    def seal(self, nonce: bytes) -> bytes:
[agent_autonomy] ./core/time_lock.py:17:        expiry_bucket = int(time.time() * 1000 // self.ttl_ms)
[agent_autonomy] ./core/time_lock.py:20:    def verify(self, nonce: bytes, seal: bytes) -> bool:
[agent_autonomy] ./core/time_lock.py:24:        expiry_bucket = int(time.time() * 1000 // self.ttl_ms)
[agent_autonomy] ./core/packet.py:2:    def __init__(self, msg_id, frag_id, total_frags, payload, is_dummy=False, signature=None):
[agent_autonomy] ./core/packet.py:3:        self.msg_id = msg_id
[agent_autonomy] ./core/packet.py:4:        self.frag_id = frag_id
[agent_autonomy] ./core/packet.py:5:        self.total_frags = total_frags
[agent_autonomy] ./core/packet.py:6:        self.payload = payload
[agent_autonomy] ./core/packet.py:7:        self.is_dummy = is_dummy
[agent_autonomy] ./core/packet.py:8:        self.signature = signature
[agent_autonomy] ./core/packet.py:10:    def signable(self):
[agent_autonomy] ./core/packet.py:11:        if self.is_dummy:
[agent_autonomy] ./core/packet.py:12:            return self.msg_id + b"DUMMY"
[agent_autonomy] ./core/packet.py:13:        return self.msg_id + self.frag_id.to_bytes(4, "big") + self.payload
[agent_autonomy] ./core/signature.py:8:    def sign(self, data: bytes, key: bytes) -> bytes:
[agent_autonomy] ./core/signature.py:11:    def verify(self, data: bytes, signature: bytes, key: bytes) -> bool:
[agent_autonomy] ./core/crypto/encryption.py:4:    def __init__(self, key):
[agent_autonomy] ./core/crypto/encryption.py:5:        self.key = key
[agent_autonomy] ./core/crypto/encryption.py:7:    def seal(self, data):
[agent_autonomy] ./core/crypto/encryption.py:9:        cipher = AES.new(self.key, AES.MODE_GCM)
[agent_autonomy] ./core/crypto/encryption.py:13:    def open(self, bundle):
[agent_autonomy] ./core/crypto/encryption.py:16:            cipher = AES.new(self.key, AES.MODE_GCM, nonce=bundle["n"])
[agent_autonomy] ./core/crypto/ca.py:7:    def __init__(self):
[agent_autonomy] ./core/crypto/ca.py:8:        self._key = RSA.generate(2048)
[agent_autonomy] ./core/crypto/ca.py:9:        self.public_key = self._key.publickey()
[agent_autonomy] ./core/crypto/ca.py:11:    def sign(self, data: bytes) -> bytes:
[agent_autonomy] ./core/crypto/ca.py:13:        return pkcs1_15.new(self._key).sign(h)
[agent_autonomy] ./core/crypto/ca.py:15:    def verify(self, data: bytes, signature: bytes) -> bool:
[agent_autonomy] ./core/crypto/ca.py:18:            pkcs1_15.new(self.public_key).verify(h, signature)
[agent_autonomy] ./agents/receiver_agent.py:2:    def verify(self, packets):
[agent_autonomy] ./agents/receiver_agent.py:4:receiver_agent.py
[agent_autonomy] ./agents/secure_agent.py:6:    def __init__(self, master_key):
[agent_autonomy] ./agents/secure_agent.py:7:        self.master_key = master_key
[agent_autonomy] ./agents/secure_agent.py:8:        self.locked = False
[agent_autonomy] ./agents/secure_agent.py:9:        self.pressure = 0.0
[agent_autonomy] ./agents/secure_agent.py:10:        self.fragment_count = 12 
[agent_autonomy] ./agents/secure_agent.py:11:        self.threshold = 12
[agent_autonomy] ./agents/secure_agent.py:13:    def is_locked(self):
[agent_autonomy] ./agents/secure_agent.py:14:        return self.locked
[agent_autonomy] ./agents/secure_agent.py:16:    def observe(self, loss):
[agent_autonomy] ./agents/secure_agent.py:17:        if self.locked: return
[agent_autonomy] ./agents/secure_agent.py:18:        self.threshold = max(4, int(self.fragment_count * (1.0 - loss)))
[agent_autonomy] ./agents/secure_agent.py:20:    def add_attack_pressure(self, amount):
[agent_autonomy] ./agents/secure_agent.py:21:        if self.locked: return
[agent_autonomy] ./agents/secure_agent.py:22:        self.pressure += amount
[agent_autonomy] ./agents/secure_agent.py:23:        if self.pressure >= self.PRESSURE_LIMIT:
[agent_autonomy] ./agents/secure_agent.py:24:            self.locked = True
[agent_autonomy] ./agents/secure_agent.py:25:            print(f"[V1-SECURITY] LOCKOUT TRIGGERED -> Pressure: {self.pressure:.2f}")
[agent_autonomy] ./agents/secure_agent.py:27:    def get_layer_key(self, layer_id):
[agent_autonomy] ./agents/secure_agent.py:28:        return hashlib.sha256(self.master_key + str(layer_id).encode()).digest()
[agent_autonomy] ./agents/sender_agent.py:2:    def adapt(self, threat_level):
[agent_autonomy] ./agents/network_agent.py:2:    def observe(self, congestion, loss, flood):
[agent_autonomy] ./agents/learning_agent.py:3:    Online adaptive security agent.
[agent_autonomy] ./agents/learning_agent.py:8:    def __init__(self):
[agent_autonomy] ./agents/learning_agent.py:9:        self.loss_ema = 0.0
[agent_autonomy] ./agents/learning_agent.py:10:        self.delay_ema = 0.0
[agent_autonomy] ./agents/learning_agent.py:11:        self.alpha = 0.2  # learning rate
[agent_autonomy] ./agents/learning_agent.py:13:        self.fragment_count = 8
[agent_autonomy] ./agents/learning_agent.py:14:        self.dummy_ratio = 1.0
[agent_autonomy] ./agents/learning_agent.py:16:    def observe(self, loss, delay):
[agent_autonomy] ./agents/learning_agent.py:17:        self.loss_ema = (1 - self.alpha) * self.loss_ema + self.alpha * loss
[agent_autonomy] ./agents/learning_agent.py:18:        self.delay_ema = (1 - self.alpha) * self.delay_ema + self.alpha * delay
[agent_autonomy] ./agents/learning_agent.py:20:    def act(self):
[agent_autonomy] ./agents/learning_agent.py:21:        threat = min(1.0, self.loss_ema + self.delay_ema)
[agent_autonomy] ./agents/learning_agent.py:24:        self.fragment_count = 8 + int(6 * threat)
[agent_autonomy] ./agents/learning_agent.py:25:        self.dummy_ratio = 1.0 + 2.0 * threat
[agent_autonomy] ./agents/learning_agent.py:27:        return self.fragment_count, self.dummy_ratio
[agent_autonomy] ./v2_model/agents/secure_agent_v2.py:5:    def __init__(self, key):
[agent_autonomy] ./v2_model/agents/secure_agent_v2.py:6:        self.key = key
[agent_autonomy] ./v2_model/agents/secure_agent_v2.py:7:        self.locked = False
[agent_autonomy] ./v2_model/agents/secure_agent_v2.py:8:    def is_fresh(self, ts):
[agent_autonomy] ./v2_model/agents/secure_agent_v2.py:9:        return (time.time() - ts) < self.TIME_WINDOW

[entropy_control] ./tests/verify_v1.py:3:from core.crypto.entropy import verify_stealth
[entropy_control] ./tests/verify_final.py:3:from core.crypto.entropy import verify_indistinguishability
[entropy_control] ./aegis_grid.egg-info/SOURCES.txt:33:core/crypto/entropy.py
[entropy_control] ./generate_validation.py:6:from core.crypto.entropy import calculate_entropy
[entropy_control] ./generate_validation.py:20:    h_cipher = calculate_entropy(res['ciphertext'])
[entropy_control] ./generate_validation.py:21:    h_dummy = calculate_entropy(os.urandom(len(res['ciphertext'])))
[entropy_control] ./core/superposition.py:2:# Constant-entropy system parameters
[entropy_control] ./core/crypto/entropy.py:4:def shannon_entropy(data: bytes) -> float:
[entropy_control] ./core/crypto/entropy.py:7:    entropy = 0.0
[entropy_control] ./core/crypto/entropy.py:10:        entropy -= p * math.log2(p)
[entropy_control] ./core/crypto/entropy.py:11:    return entropy
[entropy_control] ./core/crypto/entropy.py:18:    return abs(shannon_entropy(b1) - shannon_entropy(b2)) < delta
[entropy_control] ./network/traffic_shaper.py:3:def constant_entropy_send(packets, window_ms=50):
[fail_secure] ./core/time_lock.py:6:    Enforces irreversible message expiry.
[attack_pressure] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[attack_pressure] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[attack_pressure] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[attack_pressure] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[attack_pressure] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[attack_pressure] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[attack_pressure] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[attack_pressure] ./generate_plots.py:8:    pressure = np.cumsum([0.2, 0.5, 0.8, 1.5, 2.5])
[attack_pressure] ./generate_plots.py:24:    plt.step(range(len(pressure)), pressure, where='post', color='purple', label='CAP Score')
[attack_pressure] ./agents/secure_agent.py:9:        self.pressure = 0.0
[attack_pressure] ./agents/secure_agent.py:20:    def add_attack_pressure(self, amount):
[attack_pressure] ./agents/secure_agent.py:22:        self.pressure += amount
[attack_pressure] ./agents/secure_agent.py:23:        if self.pressure >= self.PRESSURE_LIMIT:
[attack_pressure] ./agents/secure_agent.py:25:            print(f"[V1-SECURITY] LOCKOUT TRIGGERED -> Pressure: {self.pressure:.2f}")
[adaptive_threshold] ./protocol/receiver.py:7:    if len(packets) < agent.threshold:
[adaptive_threshold] ./protocol/receiver.py:25:    return len(seen) >= agent.threshold
[adaptive_threshold] ./Aegis_Grid_V2_Technical_Summary.txt:11:- Autonomous (n, k) threshold adaptation based on real-time stochastic loss.
[adaptive_threshold] ./agents/secure_agent.py:11:        self.threshold = 12
[adaptive_threshold] ./agents/secure_agent.py:18:        self.threshold = max(4, int(self.fragment_count * (1.0 - loss)))
[adaptive_threshold] ./agents/learning_agent.py:3:    Online adaptive security agent.
[agent_autonomy] ./protocol/receiver.py:3:def receive_and_reconstruct(packets, agent):
[agent_autonomy] ./protocol/receiver.py:4:    if agent.is_locked() or not packets:
[agent_autonomy] ./protocol/receiver.py:7:    if len(packets) < agent.threshold:
[agent_autonomy] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[agent_autonomy] ./protocol/receiver.py:9:        if agent.is_locked():
[agent_autonomy] ./protocol/receiver.py:17:        key = agent.get_layer_key(p.frag_id)
[agent_autonomy] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[agent_autonomy] ./protocol/receiver.py:22:        if agent.is_locked():
[agent_autonomy] ./protocol/receiver.py:25:    return len(seen) >= agent.threshold
[agent_autonomy] ./protocol/packet.py:4:    def __init__(self, ciphertext, nonce, tag, cert, timestamp):
[agent_autonomy] ./protocol/packet.py:5:        self.ciphertext = ciphertext
[agent_autonomy] ./protocol/packet.py:6:        self.nonce = nonce
[agent_autonomy] ./protocol/packet.py:7:        self.tag = tag
[agent_autonomy] ./protocol/packet.py:8:        self.cert = cert
[agent_autonomy] ./protocol/packet.py:9:        self.timestamp = timestamp
[agent_autonomy] ./protocol/sender.py:6:def generate_traffic(agent, data, dummy_ratio):
[agent_autonomy] ./protocol/sender.py:7:    assert hasattr(agent, "fragment_count"), "Agent contract violated"
[agent_autonomy] ./protocol/sender.py:14:        layer_key = agent.get_layer_key(i)
[agent_autonomy] ./protocol/sender.py:19:            total_frags=agent.fragment_count,
[agent_autonomy] ./protocol/sender.py:30:        pkt = Packet(msg_id, i, agent.fragment_count, os.urandom(1))
[agent_autonomy] ./protocol/sender.py:31:        pkt.signature = signer.sign(pkt.signable(), agent.get_layer_key(i))
[agent_autonomy] ./simulation/run_experiments.py:4:def run_all(agent, traffic_fn, receiver_fn):
[agent_autonomy] ./simulation/run_experiments.py:13:            agent.locked = False
[agent_autonomy] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[agent_autonomy] ./simulation/run_experiments.py:15:            agent._lock_announced = False
[agent_autonomy] ./simulation/run_experiments.py:18:            agent.observe(loss)
[agent_autonomy] ./simulation/run_experiments.py:21:            packets = traffic_fn(agent, b"POWER_GRID_CMD", 0.2)
[agent_autonomy] ./simulation/run_experiments.py:25:            if agent.is_locked():
[agent_autonomy] ./simulation/run_experiments.py:27:            elif receiver_fn(packets, agent):
[agent_autonomy] ./tests/verify_v1.py:4:from agents.secure_agent import SecureAgent
[agent_autonomy] ./tests/verify_v1.py:19:    agent = SecureAgent(os.urandom(32))
[agent_autonomy] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[agent_autonomy] ./tests/verify_v1.py:21:    print(f"Layer 7 (Safety):   {'✅ LOCKED' if agent.is_locked() else '❌ FAIL'}")
[agent_autonomy] ./tests/verify_final.py:4:from agents.secure_agent import SecureAgent
[agent_autonomy] ./tests/verify_final.py:24:    agent = SecureAgent(os.urandom(32))
[agent_autonomy] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[agent_autonomy] ./tests/verify_v2.py:4:from agents.secure_agent import SecureAgentV2
[agent_autonomy] ./tests/verify_v2.py:14:    agent = SecureAgentV2(os.urandom(32))
[agent_autonomy] ./tests/verify_v2.py:16:    print(f"Layer 7 (Time-Freshness):  {'✅ VALID' if agent.is_time_valid(valid_ts) else '❌ FAIL'}")
[agent_autonomy] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[agent_autonomy] ./tests/verify_v2.py:19:    print(f"Layer 7 (Safety Sink):     {'✅ LOCKED' if agent.is_locked() else '❌ FAIL'}")
[agent_autonomy] ./receiver.py:4:    def __init__(self, agent):
[agent_autonomy] ./receiver.py:5:        self.agent = agent
[agent_autonomy] ./receiver.py:7:        self.epoch_size = 10
[agent_autonomy] ./receiver.py:8:        self.epoch_invalid = 0
[agent_autonomy] ./receiver.py:9:        self.epoch_total = 0
[agent_autonomy] ./receiver.py:11:        self.bad_epochs = deque(maxlen=3)
[agent_autonomy] ./receiver.py:13:    def receive(self, fragments, forged=False, replay=False):
[agent_autonomy] ./receiver.py:14:        if self.agent.locked:
[agent_autonomy] ./receiver.py:17:        self.epoch_total += len(fragments)
[agent_autonomy] ./receiver.py:20:            self.epoch_invalid += len(fragments)
[agent_autonomy] ./receiver.py:22:        if self.epoch_total >= self.epoch_size:
[agent_autonomy] ./receiver.py:23:            ratio = self.epoch_invalid / self.epoch_total
[agent_autonomy] ./receiver.py:24:            if ratio > self.agent.max_invalid_ratio:
[agent_autonomy] ./receiver.py:25:                print(f"[SECURITY] FORGERY sustained {self.epoch_invalid}/{self.epoch_total} → NODE LOCKED")
[agent_autonomy] ./receiver.py:26:                self.agent.locked = True
[agent_autonomy] ./receiver.py:28:            self.epoch_invalid = 0
[agent_autonomy] ./receiver.py:29:            self.epoch_total = 0
[agent_autonomy] ./error_log.txt:2:  File "/workspaces/agentic-secure-grid-communication/main.py", line 3, in <module>
[agent_autonomy] ./error_log.txt:4:  File "/workspaces/agentic-secure-grid-communication/protocol/sender.py", line 3, in <module>
[agent_autonomy] ./error_log.txt:6:  File "/workspaces/agentic-secure-grid-communication/core/crypto.py", line 13
[agent_autonomy] ./error_log.txt:7:    return data        cd /workspaces/agentic-secure-grid-communication && python main.py 2>&1 | tee error_log.txt
[agent_autonomy] ./main.py:2:from agents.secure_agent import SecureAgent
[agent_autonomy] ./main.py:20:        agent = SecureAgent(master_key)
[agent_autonomy] ./main.py:21:        run_all(agent, generate_traffic, receive_and_reconstruct)
[agent_autonomy] ./aegis_grid.egg-info/SOURCES.txt:10:aegis_grid/agents/__init__.py
[agent_autonomy] ./aegis_grid.egg-info/SOURCES.txt:14:agents/__init__.py
[agent_autonomy] ./aegis_grid.egg-info/SOURCES.txt:15:agents/learning_agent.py
[agent_autonomy] ./aegis_grid.egg-info/SOURCES.txt:16:agents/network_agent.py
[agent_autonomy] ./aegis_grid.egg-info/SOURCES.txt:17:agents/receiver_agent.py
[agent_autonomy] ./aegis_grid.egg-info/SOURCES.txt:18:agents/secure_agent.py
[agent_autonomy] ./aegis_grid.egg-info/SOURCES.txt:19:agents/sender_agent.py
[agent_autonomy] ./aegis_grid.egg-info/top_level.txt:2:agents
[agent_autonomy] ./verify_model.py:2:from agents.secure_agent import SecureAgent
[agent_autonomy] ./verify_model.py:9:        "Agentic CAP Logic": "agents/secure_agent.py",
[agent_autonomy] ./.vault/logic_blueprints/audit_v2.py:9:from v2_model.agents.secure_agent_v2 import AgentV2
[agent_autonomy] ./.vault/logic_blueprints/audit_v2.py:20:    agent = AgentV2(os.urandom(32))
[agent_autonomy] ./.vault/logic_blueprints/audit_v2.py:21:    print(f"Time-Bounded Policy:     {'✅ ACTIVE' if agent.is_fresh(time.time() - 0.5) else '❌ FAIL'}")
[agent_autonomy] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[agent_autonomy] ./.vault/logic_blueprints/audit_v2.py:25:    print(f"V2 Safety Sink:          {'✅ LOCKED' if agent.locked else '❌ FAIL'}")
[agent_autonomy] ./.novelty_state/current.txt:15:[attack_pressure] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[agent_autonomy] ./.novelty_state/current.txt:16:[attack_pressure] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[agent_autonomy] ./.novelty_state/current.txt:17:[attack_pressure] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[agent_autonomy] ./.novelty_state/current.txt:18:[attack_pressure] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[agent_autonomy] ./.novelty_state/current.txt:19:[attack_pressure] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[agent_autonomy] ./.novelty_state/current.txt:20:[attack_pressure] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[agent_autonomy] ./.novelty_state/current.txt:21:[attack_pressure] ./.vault/logic_blueprints/audit_v2.py:24:    agent.update_pressure(6.0)
[agent_autonomy] ./.novelty_state/current.txt:24:[attack_pressure] ./agents/secure_agent.py:9:        self.pressure = 0.0
[agent_autonomy] ./.novelty_state/current.txt:25:[attack_pressure] ./agents/secure_agent.py:20:    def add_attack_pressure(self, amount):
[agent_autonomy] ./.novelty_state/current.txt:26:[attack_pressure] ./agents/secure_agent.py:22:        self.pressure += amount
[agent_autonomy] ./.novelty_state/current.txt:27:[attack_pressure] ./agents/secure_agent.py:23:        if self.pressure >= self.PRESSURE_LIMIT:
[agent_autonomy] ./.novelty_state/current.txt:28:[attack_pressure] ./agents/secure_agent.py:25:            print(f"[V1-SECURITY] LOCKOUT TRIGGERED -> Pressure: {self.pressure:.2f}")
[agent_autonomy] ./.novelty_state/current.txt:29:[adaptive_threshold] ./protocol/receiver.py:7:    if len(packets) < agent.threshold:
[agent_autonomy] ./.novelty_state/current.txt:30:[adaptive_threshold] ./protocol/receiver.py:25:    return len(seen) >= agent.threshold
[agent_autonomy] ./.novelty_state/current.txt:32:[adaptive_threshold] ./agents/secure_agent.py:11:        self.threshold = 12
[agent_autonomy] ./.novelty_state/current.txt:33:[adaptive_threshold] ./agents/secure_agent.py:18:        self.threshold = max(4, int(self.fragment_count * (1.0 - loss)))
[agent_autonomy] ./.novelty_state/current.txt:34:[adaptive_threshold] ./agents/learning_agent.py:3:    Online adaptive security agent.
[agent_autonomy] ./.novelty_state/current.txt:35:[agent_autonomy] ./protocol/receiver.py:3:def receive_and_reconstruct(packets, agent):
[agent_autonomy] ./.novelty_state/current.txt:36:[agent_autonomy] ./protocol/receiver.py:4:    if agent.is_locked() or not packets:
[agent_autonomy] ./.novelty_state/current.txt:37:[agent_autonomy] ./protocol/receiver.py:7:    if len(packets) < agent.threshold:
[agent_autonomy] ./.novelty_state/current.txt:38:[agent_autonomy] ./protocol/receiver.py:8:        agent.add_attack_pressure(1.0)
[agent_autonomy] ./.novelty_state/current.txt:39:[agent_autonomy] ./protocol/receiver.py:9:        if agent.is_locked():
[agent_autonomy] ./.novelty_state/current.txt:40:[agent_autonomy] ./protocol/receiver.py:17:        key = agent.get_layer_key(p.frag_id)
[agent_autonomy] ./.novelty_state/current.txt:41:[agent_autonomy] ./protocol/receiver.py:21:            agent.add_attack_pressure(1.5)
[agent_autonomy] ./.novelty_state/current.txt:42:[agent_autonomy] ./protocol/receiver.py:22:        if agent.is_locked():
[agent_autonomy] ./.novelty_state/current.txt:43:[agent_autonomy] ./protocol/receiver.py:25:    return len(seen) >= agent.threshold
[agent_autonomy] ./.novelty_state/current.txt:44:[agent_autonomy] ./protocol/packet.py:4:    def __init__(self, ciphertext, nonce, tag, cert, timestamp):
[agent_autonomy] ./.novelty_state/current.txt:45:[agent_autonomy] ./protocol/packet.py:5:        self.ciphertext = ciphertext
[agent_autonomy] ./.novelty_state/current.txt:46:[agent_autonomy] ./protocol/packet.py:6:        self.nonce = nonce
[agent_autonomy] ./.novelty_state/current.txt:47:[agent_autonomy] ./protocol/packet.py:7:        self.tag = tag
[agent_autonomy] ./.novelty_state/current.txt:48:[agent_autonomy] ./protocol/packet.py:8:        self.cert = cert
[agent_autonomy] ./.novelty_state/current.txt:49:[agent_autonomy] ./protocol/packet.py:9:        self.timestamp = timestamp
[agent_autonomy] ./.novelty_state/current.txt:50:[agent_autonomy] ./protocol/sender.py:6:def generate_traffic(agent, data, dummy_ratio):
[agent_autonomy] ./.novelty_state/current.txt:51:[agent_autonomy] ./protocol/sender.py:7:    assert hasattr(agent, "fragment_count"), "Agent contract violated"
[agent_autonomy] ./.novelty_state/current.txt:52:[agent_autonomy] ./protocol/sender.py:14:        layer_key = agent.get_layer_key(i)
[agent_autonomy] ./.novelty_state/current.txt:53:[agent_autonomy] ./protocol/sender.py:19:            total_frags=agent.fragment_count,
[agent_autonomy] ./.novelty_state/current.txt:54:[agent_autonomy] ./protocol/sender.py:30:        pkt = Packet(msg_id, i, agent.fragment_count, os.urandom(1))
[agent_autonomy] ./.novelty_state/current.txt:55:[agent_autonomy] ./protocol/sender.py:31:        pkt.signature = signer.sign(pkt.signable(), agent.get_layer_key(i))
[agent_autonomy] ./.novelty_state/current.txt:56:[agent_autonomy] ./simulation/run_experiments.py:4:def run_all(agent, traffic_fn, receiver_fn):
[agent_autonomy] ./.novelty_state/current.txt:57:[agent_autonomy] ./simulation/run_experiments.py:13:            agent.locked = False
[agent_autonomy] ./.novelty_state/current.txt:58:[agent_autonomy] ./simulation/run_experiments.py:14:            agent.pressure = 0.0
[agent_autonomy] ./.novelty_state/current.txt:59:[agent_autonomy] ./simulation/run_experiments.py:15:            agent._lock_announced = False
[agent_autonomy] ./.novelty_state/current.txt:60:[agent_autonomy] ./simulation/run_experiments.py:18:            agent.observe(loss)
[agent_autonomy] ./.novelty_state/current.txt:61:[agent_autonomy] ./simulation/run_experiments.py:21:            packets = traffic_fn(agent, b"POWER_GRID_CMD", 0.2)
[agent_autonomy] ./.novelty_state/current.txt:62:[agent_autonomy] ./simulation/run_experiments.py:25:            if agent.is_locked():
[agent_autonomy] ./.novelty_state/current.txt:63:[agent_autonomy] ./simulation/run_experiments.py:27:            elif receiver_fn(packets, agent):
[agent_autonomy] ./.novelty_state/current.txt:64:[agent_autonomy] ./tests/verify_v1.py:4:from agents.secure_agent import SecureAgent
[agent_autonomy] ./.novelty_state/current.txt:65:[agent_autonomy] ./tests/verify_v1.py:19:    agent = SecureAgent(os.urandom(32))
[agent_autonomy] ./.novelty_state/current.txt:66:[agent_autonomy] ./tests/verify_v1.py:20:    agent.add_attack_pressure(10.0)
[agent_autonomy] ./.novelty_state/current.txt:67:[agent_autonomy] ./tests/verify_v1.py:21:    print(f"Layer 7 (Safety):   {'✅ LOCKED' if agent.is_locked() else '❌ FAIL'}")
[agent_autonomy] ./.novelty_state/current.txt:68:[agent_autonomy] ./tests/verify_final.py:4:from agents.secure_agent import SecureAgent
[agent_autonomy] ./.novelty_state/current.txt:69:[agent_autonomy] ./tests/verify_final.py:24:    agent = SecureAgent(os.urandom(32))
[agent_autonomy] ./.novelty_state/current.txt:70:[agent_autonomy] ./tests/verify_final.py:25:    agent.add_attack_pressure(6.0) # Trigger Lockout
[agent_autonomy] ./.novelty_state/current.txt:71:[agent_autonomy] ./tests/verify_v2.py:4:from agents.secure_agent import SecureAgentV2
[agent_autonomy] ./.novelty_state/current.txt:72:[agent_autonomy] ./tests/verify_v2.py:14:    agent = SecureAgentV2(os.urandom(32))
[agent_autonomy] ./.novelty_state/current.txt:73:[agent_autonomy] ./tests/verify_v2.py:16:    print(f"Layer 7 (Time-Freshness):  {'✅ VALID' if agent.is_time_valid(valid_ts) else '❌ FAIL'}")
[agent_autonomy] ./.novelty_state/current.txt:74:[agent_autonomy] ./tests/verify_v2.py:18:    agent.add_attack_pressure(6.0)
[agent_autonomy] ./.novelty_state/current.txt:75:[agent_autonomy] ./tests/verify_v2.py:19:    print(f"Layer 7 (Safety Sink):     {'✅ LOCKED' if agent.is_locked() else '❌ FAIL'}")
[agent_autonomy] ./.novelty_state/current.txt:76:[agent_autonomy] ./receiver.py:4:    def __init__(self, agent):
[agent_autonomy] ./.novelty_state/current.txt:77:[agent_autonomy] ./receiver.py:5:        self.agent = agent
[agent_autonomy] ./.novelty_state/current.txt:78:[agent_autonomy] ./receiver.py:7:        self.epoch_size = 10
[agent_autonomy] ./.novelty_state/current.txt:79:[agent_autonomy] ./receiver.py:8:        self.epoch_invalid = 0
[agent_autonomy] ./.novelty_state/current.txt:80:[agent_autonomy] ./receiver.py:9:        self.epoch_total = 0
[agent_autonomy] ./.novelty_state/current.txt:81:[agent_autonomy] ./receiver.py:11:        self.bad_epochs = deque(maxlen=3)
[agent_autonomy] ./.novelty_state/current.txt:82:[agent_autonomy] ./r
[agent_autonomy] ./core/crypto.py:10:    def encrypt(self, data: bytes, key: bytes) -> bytes:
[agent_autonomy] ./core/crypto.py:13:    def decrypt(self, data: bytes, key: bytes) -> bytes:
[agent_autonomy] ./core/time_lock.py:10:    def __init__(self, ttl_ms: float):
[agent_autonomy] ./core/time_lock.py:11:        self.ttl_ms = ttl_ms
[agent_autonomy] ./core/time_lock.py:13:    def seal(self, nonce: bytes) -> bytes:
[agent_autonomy] ./core/time_lock.py:17:        expiry_bucket = int(time.time() * 1000 // self.ttl_ms)
[agent_autonomy] ./core/time_lock.py:20:    def verify(self, nonce: bytes, seal: bytes) -> bool:
[agent_autonomy] ./core/time_lock.py:24:        expiry_bucket = int(time.time() * 1000 // self.ttl_ms)
[agent_autonomy] ./core/packet.py:2:    def __init__(self, msg_id, frag_id, total_frags, payload, is_dummy=False, signature=None):
[agent_autonomy] ./core/packet.py:3:        self.msg_id = msg_id
[agent_autonomy] ./core/packet.py:4:        self.frag_id = frag_id
[agent_autonomy] ./core/packet.py:5:        self.total_frags = total_frags
[agent_autonomy] ./core/packet.py:6:        self.payload = payload
[agent_autonomy] ./core/packet.py:7:        self.is_dummy = is_dummy
[agent_autonomy] ./core/packet.py:8:        self.signature = signature
[agent_autonomy] ./core/packet.py:10:    def signable(self):
[agent_autonomy] ./core/packet.py:11:        if self.is_dummy:
[agent_autonomy] ./core/packet.py:12:            return self.msg_id + b"DUMMY"
[agent_autonomy] ./core/packet.py:13:        return self.msg_id + self.frag_id.to_bytes(4, "big") + self.payload
[agent_autonomy] ./core/signature.py:8:    def sign(self, data: bytes, key: bytes) -> bytes:
[agent_autonomy] ./core/signature.py:11:    def verify(self, data: bytes, signature: bytes, key: bytes) -> bool:
[agent_autonomy] ./core/crypto/encryption.py:4:    def __init__(self, key):
[agent_autonomy] ./core/crypto/encryption.py:5:        self.key = key
[agent_autonomy] ./core/crypto/encryption.py:7:    def seal(self, data):
[agent_autonomy] ./core/crypto/encryption.py:9:        cipher = AES.new(self.key, AES.MODE_GCM)
[agent_autonomy] ./core/crypto/encryption.py:13:    def open(self, bundle):
[agent_autonomy] ./core/crypto/encryption.py:16:            cipher = AES.new(self.key, AES.MODE_GCM, nonce=bundle["n"])
[agent_autonomy] ./core/crypto/ca.py:7:    def __init__(self):
[agent_autonomy] ./core/crypto/ca.py:8:        self._key = RSA.generate(2048)
[agent_autonomy] ./core/crypto/ca.py:9:        self.public_key = self._key.publickey()
[agent_autonomy] ./core/crypto/ca.py:11:    def sign(self, data: bytes) -> bytes:
[agent_autonomy] ./core/crypto/ca.py:13:        return pkcs1_15.new(self._key).sign(h)
[agent_autonomy] ./core/crypto/ca.py:15:    def verify(self, data: bytes, signature: bytes) -> bool:
[agent_autonomy] ./core/crypto/ca.py:18:            pkcs1_15.new(self.public_key).verify(h, signature)
[agent_autonomy] ./agents/receiver_agent.py:2:    def verify(self, packets):
[agent_autonomy] ./agents/receiver_agent.py:4:receiver_agent.py
[agent_autonomy] ./agents/secure_agent.py:6:    def __init__(self, master_key):
[agent_autonomy] ./agents/secure_agent.py:7:        self.master_key = master_key
[agent_autonomy] ./agents/secure_agent.py:8:        self.locked = False
[agent_autonomy] ./agents/secure_agent.py:9:        self.pressure = 0.0
[agent_autonomy] ./agents/secure_agent.py:10:        self.fragment_count = 12 
[agent_autonomy] ./agents/secure_agent.py:11:        self.threshold = 12
[agent_autonomy] ./agents/secure_agent.py:13:    def is_locked(self):
[agent_autonomy] ./agents/secure_agent.py:14:        return self.locked
[agent_autonomy] ./agents/secure_agent.py:16:    def observe(self, loss):
[agent_autonomy] ./agents/secure_agent.py:17:        if self.locked: return
[agent_autonomy] ./agents/secure_agent.py:18:        self.threshold = max(4, int(self.fragment_count * (1.0 - loss)))
[agent_autonomy] ./agents/secure_agent.py:20:    def add_attack_pressure(self, amount):
[agent_autonomy] ./agents/secure_agent.py:21:        if self.locked: return
[agent_autonomy] ./agents/secure_agent.py:22:        self.pressure += amount
[agent_autonomy] ./agents/secure_agent.py:23:        if self.pressure >= self.PRESSURE_LIMIT:
[agent_autonomy] ./agents/secure_agent.py:24:            self.locked = True
[agent_autonomy] ./agents/secure_agent.py:25:            print(f"[V1-SECURITY] LOCKOUT TRIGGERED -> Pressure: {self.pressure:.2f}")
[agent_autonomy] ./agents/secure_agent.py:27:    def get_layer_key(self, layer_id):
[agent_autonomy] ./agents/secure_agent.py:28:        return hashlib.sha256(self.master_key + str(layer_id).encode()).digest()
[agent_autonomy] ./agents/sender_agent.py:2:    def adapt(self, threat_level):
[agent_autonomy] ./agents/network_agent.py:2:    def observe(self, congestion, loss, flood):
[agent_autonomy] ./agents/learning_agent.py:3:    Online adaptive security agent.
[agent_autonomy] ./agents/learning_agent.py:8:    def __init__(self):
[agent_autonomy] ./agents/learning_agent.py:9:        self.loss_ema = 0.0
[agent_autonomy] ./agents/learning_agent.py:10:        self.delay_ema = 0.0
[agent_autonomy] ./agents/learning_agent.py:11:        self.alpha = 0.2  # learning rate
[agent_autonomy] ./agents/learning_agent.py:13:        self.fragment_count = 8
[agent_autonomy] ./agents/learning_agent.py:14:        self.dummy_ratio = 1.0
[agent_autonomy] ./agents/learning_agent.py:16:    def observe(self, loss, delay):
[agent_autonomy] ./agents/learning_agent.py:17:        self.loss_ema = (1 - self.alpha) * self.loss_ema + self.alpha * loss
[agent_autonomy] ./agents/learning_agent.py:18:        self.delay_ema = (1 - self.alpha) * self.delay_ema + self.alpha * delay
[agent_autonomy] ./agents/learning_agent.py:20:    def act(self):
[agent_autonomy] ./agents/learning_agent.py:21:        threat = min(1.0, self.loss_ema + self.delay_ema)
[agent_autonomy] ./agents/learning_agent.py:24:        self.fragment_count = 8 + int(6 * threat)
[agent_autonomy] ./agents/learning_agent.py:25:        self.dummy_ratio = 1.0 + 2.0 * threat
[agent_autonomy] ./agents/learning_agent.py:27:        return self.fragment_count, self.dummy_ratio
[agent_autonomy] ./v2_model/agents/secure_agent_v2.py:5:    def __init__(self, key):
[agent_autonomy] ./v2_model/agents/secure_agent_v2.py:6:        self.key = key
[agent_autonomy] ./v2_model/agents/secure_agent_v2.py:7:        self.locked = False
[agent_autonomy] ./v2_model/agents/secure_agent_v2.py:8:    def is_fresh(self, ts):
[agent_autonomy] ./v2_model/agents/secure_agent_v2.py:9:        return (time.time() - ts) < self.TIME_WINDOW
